/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.10.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type KVAPI interface {

	/*
	KVCreate Add a kv store

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return KVAPIKVCreateRequest
	*/
	KVCreate(ctx context.Context, organization string, project string) KVAPIKVCreateRequest

	// KVCreateExecute executes the request
	//  @return V2Store
	KVCreateExecute(r KVAPIKVCreateRequest) (*V2Store, *http.Response, error)

	/*
	KVDelete Delete a kv store

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param storeId
	@return KVAPIKVDeleteRequest
	*/
	KVDelete(ctx context.Context, organization string, project string, storeId string) KVAPIKVDeleteRequest

	// KVDeleteExecute executes the request
	KVDeleteExecute(r KVAPIKVDeleteRequest) (*http.Response, error)

	/*
	KVItemsCreate Add an item to a kv store

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param storeId
	@return KVAPIKVItemsCreateRequest
	*/
	KVItemsCreate(ctx context.Context, organization string, project string, storeId string) KVAPIKVItemsCreateRequest

	// KVItemsCreateExecute executes the request
	//  @return KVItemsCreate200Response
	KVItemsCreateExecute(r KVAPIKVItemsCreateRequest) (*KVItemsCreate200Response, *http.Response, error)

	/*
	KVItemsDelete Delete an item from a kv store

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param storeId
	@param key
	@return KVAPIKVItemsDeleteRequest
	*/
	KVItemsDelete(ctx context.Context, organization string, project string, storeId string, key string) KVAPIKVItemsDeleteRequest

	// KVItemsDeleteExecute executes the request
	//  @return KVItemsDelete200Response
	KVItemsDeleteExecute(r KVAPIKVItemsDeleteRequest) (*KVItemsDelete200Response, *http.Response, error)

	/*
	KVItemsList List items in a kv store

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param storeId
	@return KVAPIKVItemsListRequest
	*/
	KVItemsList(ctx context.Context, organization string, project string, storeId string) KVAPIKVItemsListRequest

	// KVItemsListExecute executes the request
	//  @return V2StoreItemsListResponse
	KVItemsListExecute(r KVAPIKVItemsListRequest) (*V2StoreItemsListResponse, *http.Response, error)

	/*
	KVItemsShow Get an item from a kv store

	Retrieves an item from the KV store. **Security Note:** If the item was stored as a secret (secret=true), the value will be redacted and returned as '[ENCRYPTED]' for security. Secrets should be accessed directly via the Quant Cloud platform KVStore abstraction.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param storeId
	@param key
	@return KVAPIKVItemsShowRequest
	*/
	KVItemsShow(ctx context.Context, organization string, project string, storeId string, key string) KVAPIKVItemsShowRequest

	// KVItemsShowExecute executes the request
	//  @return KVItemsShow200Response
	KVItemsShowExecute(r KVAPIKVItemsShowRequest) (*KVItemsShow200Response, *http.Response, error)

	/*
	KVItemsUpdate Update an item in a kv store

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param storeId
	@param key
	@return KVAPIKVItemsUpdateRequest
	*/
	KVItemsUpdate(ctx context.Context, organization string, project string, storeId string, key string) KVAPIKVItemsUpdateRequest

	// KVItemsUpdateExecute executes the request
	//  @return KVItemsCreate200Response
	KVItemsUpdateExecute(r KVAPIKVItemsUpdateRequest) (*KVItemsCreate200Response, *http.Response, error)

	/*
	KVLinkToProject Link a KV store to another project

	Share a KV store from the source project with a target project. The store will be accessible in the target project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Source project identifier
	@param storeId KV store identifier
	@return KVAPIKVLinkToProjectRequest
	*/
	KVLinkToProject(ctx context.Context, organization string, project string, storeId string) KVAPIKVLinkToProjectRequest

	// KVLinkToProjectExecute executes the request
	//  @return KVLinkToProject200Response
	KVLinkToProjectExecute(r KVAPIKVLinkToProjectRequest) (*KVLinkToProject200Response, *http.Response, error)

	/*
	KVList List key-value stores

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return KVAPIKVListRequest
	*/
	KVList(ctx context.Context, organization string, project string) KVAPIKVListRequest

	// KVListExecute executes the request
	//  @return []V2Store
	KVListExecute(r KVAPIKVListRequest) ([]V2Store, *http.Response, error)

	/*
	KVShow Get a kv store

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param storeId
	@return KVAPIKVShowRequest
	*/
	KVShow(ctx context.Context, organization string, project string, storeId string) KVAPIKVShowRequest

	// KVShowExecute executes the request
	//  @return V2Store
	KVShowExecute(r KVAPIKVShowRequest) (*V2Store, *http.Response, error)

	/*
	KVUnlinkFromProject Unlink a KV store from this project

	Remove access to a linked KV store from this project. The store must be linked (not owned by this project).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param storeId KV store identifier
	@return KVAPIKVUnlinkFromProjectRequest
	*/
	KVUnlinkFromProject(ctx context.Context, organization string, project string, storeId string) KVAPIKVUnlinkFromProjectRequest

	// KVUnlinkFromProjectExecute executes the request
	//  @return KVLinkToProject200Response
	KVUnlinkFromProjectExecute(r KVAPIKVUnlinkFromProjectRequest) (*KVLinkToProject200Response, *http.Response, error)
}

// KVAPIService KVAPI service
type KVAPIService service

type KVAPIKVCreateRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	v2StoreRequest *V2StoreRequest
}

func (r KVAPIKVCreateRequest) V2StoreRequest(v2StoreRequest V2StoreRequest) KVAPIKVCreateRequest {
	r.v2StoreRequest = &v2StoreRequest
	return r
}

func (r KVAPIKVCreateRequest) Execute() (*V2Store, *http.Response, error) {
	return r.ApiService.KVCreateExecute(r)
}

/*
KVCreate Add a kv store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return KVAPIKVCreateRequest
*/
func (a *KVAPIService) KVCreate(ctx context.Context, organization string, project string) KVAPIKVCreateRequest {
	return KVAPIKVCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2Store
func (a *KVAPIService) KVCreateExecute(r KVAPIKVCreateRequest) (*V2Store, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2Store
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2StoreRequest == nil {
		return localVarReturnValue, nil, reportError("v2StoreRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2StoreRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KVAPIKVDeleteRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	storeId string
}

func (r KVAPIKVDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.KVDeleteExecute(r)
}

/*
KVDelete Delete a kv store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param storeId
 @return KVAPIKVDeleteRequest
*/
func (a *KVAPIService) KVDelete(ctx context.Context, organization string, project string, storeId string) KVAPIKVDeleteRequest {
	return KVAPIKVDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		storeId: storeId,
	}
}

// Execute executes the request
func (a *KVAPIService) KVDeleteExecute(r KVAPIKVDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KVAPIKVItemsCreateRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	storeId string
	v2StoreItemRequest *V2StoreItemRequest
}

func (r KVAPIKVItemsCreateRequest) V2StoreItemRequest(v2StoreItemRequest V2StoreItemRequest) KVAPIKVItemsCreateRequest {
	r.v2StoreItemRequest = &v2StoreItemRequest
	return r
}

func (r KVAPIKVItemsCreateRequest) Execute() (*KVItemsCreate200Response, *http.Response, error) {
	return r.ApiService.KVItemsCreateExecute(r)
}

/*
KVItemsCreate Add an item to a kv store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param storeId
 @return KVAPIKVItemsCreateRequest
*/
func (a *KVAPIService) KVItemsCreate(ctx context.Context, organization string, project string, storeId string) KVAPIKVItemsCreateRequest {
	return KVAPIKVItemsCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return KVItemsCreate200Response
func (a *KVAPIService) KVItemsCreateExecute(r KVAPIKVItemsCreateRequest) (*KVItemsCreate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KVItemsCreate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVItemsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2StoreItemRequest == nil {
		return localVarReturnValue, nil, reportError("v2StoreItemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2StoreItemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KVAPIKVItemsDeleteRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	storeId string
	key string
}

func (r KVAPIKVItemsDeleteRequest) Execute() (*KVItemsDelete200Response, *http.Response, error) {
	return r.ApiService.KVItemsDeleteExecute(r)
}

/*
KVItemsDelete Delete an item from a kv store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param storeId
 @param key
 @return KVAPIKVItemsDeleteRequest
*/
func (a *KVAPIService) KVItemsDelete(ctx context.Context, organization string, project string, storeId string, key string) KVAPIKVItemsDeleteRequest {
	return KVAPIKVItemsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		storeId: storeId,
		key: key,
	}
}

// Execute executes the request
//  @return KVItemsDelete200Response
func (a *KVAPIService) KVItemsDeleteExecute(r KVAPIKVItemsDeleteRequest) (*KVItemsDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KVItemsDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVItemsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KVAPIKVItemsListRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	storeId string
	cursor *string
	limit *int32
	search *string
	includeValues *bool
}

// Cursor for pagination
func (r KVAPIKVItemsListRequest) Cursor(cursor string) KVAPIKVItemsListRequest {
	r.cursor = &cursor
	return r
}

// Number of items to return
func (r KVAPIKVItemsListRequest) Limit(limit int32) KVAPIKVItemsListRequest {
	r.limit = &limit
	return r
}

// Search filter for keys
func (r KVAPIKVItemsListRequest) Search(search string) KVAPIKVItemsListRequest {
	r.search = &search
	return r
}

// Include values in the response. Secret values will be redacted as &#39;[ENCRYPTED]&#39; for security.
func (r KVAPIKVItemsListRequest) IncludeValues(includeValues bool) KVAPIKVItemsListRequest {
	r.includeValues = &includeValues
	return r
}

func (r KVAPIKVItemsListRequest) Execute() (*V2StoreItemsListResponse, *http.Response, error) {
	return r.ApiService.KVItemsListExecute(r)
}

/*
KVItemsList List items in a kv store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param storeId
 @return KVAPIKVItemsListRequest
*/
func (a *KVAPIService) KVItemsList(ctx context.Context, organization string, project string, storeId string) KVAPIKVItemsListRequest {
	return KVAPIKVItemsListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return V2StoreItemsListResponse
func (a *KVAPIService) KVItemsListExecute(r KVAPIKVItemsListRequest) (*V2StoreItemsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2StoreItemsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVItemsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.limit = &defaultValue
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.includeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_values", r.includeValues, "form", "")
	} else {
		var defaultValue bool = false
		r.includeValues = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KVAPIKVItemsShowRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	storeId string
	key string
}

func (r KVAPIKVItemsShowRequest) Execute() (*KVItemsShow200Response, *http.Response, error) {
	return r.ApiService.KVItemsShowExecute(r)
}

/*
KVItemsShow Get an item from a kv store

Retrieves an item from the KV store. **Security Note:** If the item was stored as a secret (secret=true), the value will be redacted and returned as '[ENCRYPTED]' for security. Secrets should be accessed directly via the Quant Cloud platform KVStore abstraction.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param storeId
 @param key
 @return KVAPIKVItemsShowRequest
*/
func (a *KVAPIService) KVItemsShow(ctx context.Context, organization string, project string, storeId string, key string) KVAPIKVItemsShowRequest {
	return KVAPIKVItemsShowRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		storeId: storeId,
		key: key,
	}
}

// Execute executes the request
//  @return KVItemsShow200Response
func (a *KVAPIService) KVItemsShowExecute(r KVAPIKVItemsShowRequest) (*KVItemsShow200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KVItemsShow200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVItemsShow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KVAPIKVItemsUpdateRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	storeId string
	key string
	v2StoreItemUpdateRequest *V2StoreItemUpdateRequest
}

func (r KVAPIKVItemsUpdateRequest) V2StoreItemUpdateRequest(v2StoreItemUpdateRequest V2StoreItemUpdateRequest) KVAPIKVItemsUpdateRequest {
	r.v2StoreItemUpdateRequest = &v2StoreItemUpdateRequest
	return r
}

func (r KVAPIKVItemsUpdateRequest) Execute() (*KVItemsCreate200Response, *http.Response, error) {
	return r.ApiService.KVItemsUpdateExecute(r)
}

/*
KVItemsUpdate Update an item in a kv store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param storeId
 @param key
 @return KVAPIKVItemsUpdateRequest
*/
func (a *KVAPIService) KVItemsUpdate(ctx context.Context, organization string, project string, storeId string, key string) KVAPIKVItemsUpdateRequest {
	return KVAPIKVItemsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		storeId: storeId,
		key: key,
	}
}

// Execute executes the request
//  @return KVItemsCreate200Response
func (a *KVAPIService) KVItemsUpdateExecute(r KVAPIKVItemsUpdateRequest) (*KVItemsCreate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KVItemsCreate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVItemsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2StoreItemUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("v2StoreItemUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2StoreItemUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KVAPIKVLinkToProjectRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	storeId string
	kVLinkToProjectRequest *KVLinkToProjectRequest
}

func (r KVAPIKVLinkToProjectRequest) KVLinkToProjectRequest(kVLinkToProjectRequest KVLinkToProjectRequest) KVAPIKVLinkToProjectRequest {
	r.kVLinkToProjectRequest = &kVLinkToProjectRequest
	return r
}

func (r KVAPIKVLinkToProjectRequest) Execute() (*KVLinkToProject200Response, *http.Response, error) {
	return r.ApiService.KVLinkToProjectExecute(r)
}

/*
KVLinkToProject Link a KV store to another project

Share a KV store from the source project with a target project. The store will be accessible in the target project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Source project identifier
 @param storeId KV store identifier
 @return KVAPIKVLinkToProjectRequest
*/
func (a *KVAPIService) KVLinkToProject(ctx context.Context, organization string, project string, storeId string) KVAPIKVLinkToProjectRequest {
	return KVAPIKVLinkToProjectRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return KVLinkToProject200Response
func (a *KVAPIService) KVLinkToProjectExecute(r KVAPIKVLinkToProjectRequest) (*KVLinkToProject200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KVLinkToProject200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVLinkToProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/link"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kVLinkToProjectRequest == nil {
		return localVarReturnValue, nil, reportError("kVLinkToProjectRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kVLinkToProjectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KVAPIKVListRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
}

func (r KVAPIKVListRequest) Execute() ([]V2Store, *http.Response, error) {
	return r.ApiService.KVListExecute(r)
}

/*
KVList List key-value stores

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return KVAPIKVListRequest
*/
func (a *KVAPIService) KVList(ctx context.Context, organization string, project string) KVAPIKVListRequest {
	return KVAPIKVListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2Store
func (a *KVAPIService) KVListExecute(r KVAPIKVListRequest) ([]V2Store, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2Store
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KVAPIKVShowRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	storeId string
}

func (r KVAPIKVShowRequest) Execute() (*V2Store, *http.Response, error) {
	return r.ApiService.KVShowExecute(r)
}

/*
KVShow Get a kv store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param storeId
 @return KVAPIKVShowRequest
*/
func (a *KVAPIService) KVShow(ctx context.Context, organization string, project string, storeId string) KVAPIKVShowRequest {
	return KVAPIKVShowRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return V2Store
func (a *KVAPIService) KVShowExecute(r KVAPIKVShowRequest) (*V2Store, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2Store
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVShow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KVAPIKVUnlinkFromProjectRequest struct {
	ctx context.Context
	ApiService KVAPI
	organization string
	project string
	storeId string
}

func (r KVAPIKVUnlinkFromProjectRequest) Execute() (*KVLinkToProject200Response, *http.Response, error) {
	return r.ApiService.KVUnlinkFromProjectExecute(r)
}

/*
KVUnlinkFromProject Unlink a KV store from this project

Remove access to a linked KV store from this project. The store must be linked (not owned by this project).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param storeId KV store identifier
 @return KVAPIKVUnlinkFromProjectRequest
*/
func (a *KVAPIService) KVUnlinkFromProject(ctx context.Context, organization string, project string, storeId string) KVAPIKVUnlinkFromProjectRequest {
	return KVAPIKVUnlinkFromProjectRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return KVLinkToProject200Response
func (a *KVAPIService) KVUnlinkFromProjectExecute(r KVAPIKVUnlinkFromProjectRequest) (*KVLinkToProject200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KVLinkToProject200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KVAPIService.KVUnlinkFromProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/link"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

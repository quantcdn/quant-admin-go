/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.9.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AIVectorDatabaseAPI interface {

	/*
	CreateVectorCollection Create Vector Database Collection

	Creates a new vector database collection (knowledge base category) for semantic search. Collections store documents with embeddings for RAG (Retrieval Augmented Generation).
     *
     * **Use Cases:**
     * - Product documentation ('docs')
     * - Company policies ('policies')
     * - Support knowledge base ('support')
     * - Technical specifications ('specs')

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIVectorDatabaseAPICreateVectorCollectionRequest
	*/
	CreateVectorCollection(ctx context.Context, organisation string) AIVectorDatabaseAPICreateVectorCollectionRequest

	// CreateVectorCollectionExecute executes the request
	//  @return CreateVectorCollection201Response
	CreateVectorCollectionExecute(r AIVectorDatabaseAPICreateVectorCollectionRequest) (*CreateVectorCollection201Response, *http.Response, error)

	/*
	DeleteVectorCollection Delete Collection

	Deletes a vector database collection and all its documents. This action cannot be undone.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param collectionId The collection ID
	@return AIVectorDatabaseAPIDeleteVectorCollectionRequest
	*/
	DeleteVectorCollection(ctx context.Context, organisation string, collectionId string) AIVectorDatabaseAPIDeleteVectorCollectionRequest

	// DeleteVectorCollectionExecute executes the request
	//  @return DeleteVectorCollection200Response
	DeleteVectorCollectionExecute(r AIVectorDatabaseAPIDeleteVectorCollectionRequest) (*DeleteVectorCollection200Response, *http.Response, error)

	/*
	GetVectorCollection Get Collection Details

	Get detailed information about a specific vector database collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param collectionId The collection ID
	@return AIVectorDatabaseAPIGetVectorCollectionRequest
	*/
	GetVectorCollection(ctx context.Context, organisation string, collectionId string) AIVectorDatabaseAPIGetVectorCollectionRequest

	// GetVectorCollectionExecute executes the request
	//  @return GetVectorCollection200Response
	GetVectorCollectionExecute(r AIVectorDatabaseAPIGetVectorCollectionRequest) (*GetVectorCollection200Response, *http.Response, error)

	/*
	ListVectorCollections List Vector Database Collections

	Lists all vector database collections (knowledge bases) for an organization.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIVectorDatabaseAPIListVectorCollectionsRequest
	*/
	ListVectorCollections(ctx context.Context, organisation string) AIVectorDatabaseAPIListVectorCollectionsRequest

	// ListVectorCollectionsExecute executes the request
	//  @return ListVectorCollections200Response
	ListVectorCollectionsExecute(r AIVectorDatabaseAPIListVectorCollectionsRequest) (*ListVectorCollections200Response, *http.Response, error)

	/*
	QueryVectorCollection Semantic Search Query

	Performs semantic search on a collection using vector similarity. Returns the most relevant documents based on meaning, not keyword matching.
     *
     * **Three Search Modes:**
     *
     * 1. **Text Query** - Provide `query` string, server generates embedding
     *    - Query text is embedded using the collection's embedding model
     *    - Embeddings are cached for repeated queries
     *
     * 2. **Vector Query** - Provide pre-computed `vector` array
     *    - Skip embedding generation (faster)
     *    - Useful when you've already embedded the query elsewhere
     *    - Vector dimension must match collection (e.g., 1024 for Titan v2)
     *
     * 3. **Metadata List** - Set `listByMetadata: true` with `filter`
     *    - Skip semantic search entirely
     *    - Return all documents matching the filter
     *    - Supports cursor-based pagination for large datasets
     *    - Results ordered by sortBy/sortOrder (default: created_at DESC)
     *
     * **Filtering:**
     * - `filter.exact`: Exact match on metadata fields (AND logic)
     * - `filter.contains`: Array contains filter for tags (ANY match)
     * - Filters can be combined with semantic search or used alone with listByMetadata
     *
     * **Pagination (listByMetadata mode only):**
     * - Use `cursor` from previous response's `nextCursor` to get next page
     * - Uses keyset pagination for efficient traversal of large datasets
     * - Control sort with `sortBy` and `sortOrder`
     *
     * **Use Cases:**
     * - Find relevant documentation for user questions
     * - Power RAG (Retrieval Augmented Generation) in AI assistants
     * - Semantic search across knowledge bases
     * - List all artifacts by building/worker/tag

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param collectionId The collection ID
	@return AIVectorDatabaseAPIQueryVectorCollectionRequest
	*/
	QueryVectorCollection(ctx context.Context, organisation string, collectionId string) AIVectorDatabaseAPIQueryVectorCollectionRequest

	// QueryVectorCollectionExecute executes the request
	//  @return QueryVectorCollection200Response
	QueryVectorCollectionExecute(r AIVectorDatabaseAPIQueryVectorCollectionRequest) (*QueryVectorCollection200Response, *http.Response, error)

	/*
	UploadVectorDocuments Upload Documents to Collection

	Uploads documents to a vector database collection with automatic embedding generation. Documents are chunked (if needed), embedded using the collection's embedding model, and stored.
     *
     * **Supported Content:**
     * - Plain text content
     * - URLs to fetch content from
     * - Markdown documents
     *
     * **Metadata:**
     * Each document can include metadata (title, source_url, section, tags) that is returned with search results.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param collectionId The collection ID
	@return AIVectorDatabaseAPIUploadVectorDocumentsRequest
	*/
	UploadVectorDocuments(ctx context.Context, organisation string, collectionId string) AIVectorDatabaseAPIUploadVectorDocumentsRequest

	// UploadVectorDocumentsExecute executes the request
	//  @return UploadVectorDocuments200Response
	UploadVectorDocumentsExecute(r AIVectorDatabaseAPIUploadVectorDocumentsRequest) (*UploadVectorDocuments200Response, *http.Response, error)
}

// AIVectorDatabaseAPIService AIVectorDatabaseAPI service
type AIVectorDatabaseAPIService service

type AIVectorDatabaseAPICreateVectorCollectionRequest struct {
	ctx context.Context
	ApiService AIVectorDatabaseAPI
	organisation string
	createVectorCollectionRequest *CreateVectorCollectionRequest
}

func (r AIVectorDatabaseAPICreateVectorCollectionRequest) CreateVectorCollectionRequest(createVectorCollectionRequest CreateVectorCollectionRequest) AIVectorDatabaseAPICreateVectorCollectionRequest {
	r.createVectorCollectionRequest = &createVectorCollectionRequest
	return r
}

func (r AIVectorDatabaseAPICreateVectorCollectionRequest) Execute() (*CreateVectorCollection201Response, *http.Response, error) {
	return r.ApiService.CreateVectorCollectionExecute(r)
}

/*
CreateVectorCollection Create Vector Database Collection

Creates a new vector database collection (knowledge base category) for semantic search. Collections store documents with embeddings for RAG (Retrieval Augmented Generation).
     *
     * **Use Cases:**
     * - Product documentation ('docs')
     * - Company policies ('policies')
     * - Support knowledge base ('support')
     * - Technical specifications ('specs')

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIVectorDatabaseAPICreateVectorCollectionRequest
*/
func (a *AIVectorDatabaseAPIService) CreateVectorCollection(ctx context.Context, organisation string) AIVectorDatabaseAPICreateVectorCollectionRequest {
	return AIVectorDatabaseAPICreateVectorCollectionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return CreateVectorCollection201Response
func (a *AIVectorDatabaseAPIService) CreateVectorCollectionExecute(r AIVectorDatabaseAPICreateVectorCollectionRequest) (*CreateVectorCollection201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVectorCollection201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIVectorDatabaseAPIService.CreateVectorCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/vector-db/collections"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVectorCollectionRequest == nil {
		return localVarReturnValue, nil, reportError("createVectorCollectionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVectorCollectionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIVectorDatabaseAPIDeleteVectorCollectionRequest struct {
	ctx context.Context
	ApiService AIVectorDatabaseAPI
	organisation string
	collectionId string
}

func (r AIVectorDatabaseAPIDeleteVectorCollectionRequest) Execute() (*DeleteVectorCollection200Response, *http.Response, error) {
	return r.ApiService.DeleteVectorCollectionExecute(r)
}

/*
DeleteVectorCollection Delete Collection

Deletes a vector database collection and all its documents. This action cannot be undone.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param collectionId The collection ID
 @return AIVectorDatabaseAPIDeleteVectorCollectionRequest
*/
func (a *AIVectorDatabaseAPIService) DeleteVectorCollection(ctx context.Context, organisation string, collectionId string) AIVectorDatabaseAPIDeleteVectorCollectionRequest {
	return AIVectorDatabaseAPIDeleteVectorCollectionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return DeleteVectorCollection200Response
func (a *AIVectorDatabaseAPIService) DeleteVectorCollectionExecute(r AIVectorDatabaseAPIDeleteVectorCollectionRequest) (*DeleteVectorCollection200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteVectorCollection200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIVectorDatabaseAPIService.DeleteVectorCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/vector-db/collections/{collectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIVectorDatabaseAPIGetVectorCollectionRequest struct {
	ctx context.Context
	ApiService AIVectorDatabaseAPI
	organisation string
	collectionId string
}

func (r AIVectorDatabaseAPIGetVectorCollectionRequest) Execute() (*GetVectorCollection200Response, *http.Response, error) {
	return r.ApiService.GetVectorCollectionExecute(r)
}

/*
GetVectorCollection Get Collection Details

Get detailed information about a specific vector database collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param collectionId The collection ID
 @return AIVectorDatabaseAPIGetVectorCollectionRequest
*/
func (a *AIVectorDatabaseAPIService) GetVectorCollection(ctx context.Context, organisation string, collectionId string) AIVectorDatabaseAPIGetVectorCollectionRequest {
	return AIVectorDatabaseAPIGetVectorCollectionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return GetVectorCollection200Response
func (a *AIVectorDatabaseAPIService) GetVectorCollectionExecute(r AIVectorDatabaseAPIGetVectorCollectionRequest) (*GetVectorCollection200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVectorCollection200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIVectorDatabaseAPIService.GetVectorCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/vector-db/collections/{collectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIVectorDatabaseAPIListVectorCollectionsRequest struct {
	ctx context.Context
	ApiService AIVectorDatabaseAPI
	organisation string
}

func (r AIVectorDatabaseAPIListVectorCollectionsRequest) Execute() (*ListVectorCollections200Response, *http.Response, error) {
	return r.ApiService.ListVectorCollectionsExecute(r)
}

/*
ListVectorCollections List Vector Database Collections

Lists all vector database collections (knowledge bases) for an organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIVectorDatabaseAPIListVectorCollectionsRequest
*/
func (a *AIVectorDatabaseAPIService) ListVectorCollections(ctx context.Context, organisation string) AIVectorDatabaseAPIListVectorCollectionsRequest {
	return AIVectorDatabaseAPIListVectorCollectionsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListVectorCollections200Response
func (a *AIVectorDatabaseAPIService) ListVectorCollectionsExecute(r AIVectorDatabaseAPIListVectorCollectionsRequest) (*ListVectorCollections200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVectorCollections200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIVectorDatabaseAPIService.ListVectorCollections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/vector-db/collections"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIVectorDatabaseAPIQueryVectorCollectionRequest struct {
	ctx context.Context
	ApiService AIVectorDatabaseAPI
	organisation string
	collectionId string
	queryVectorCollectionRequest *QueryVectorCollectionRequest
}

func (r AIVectorDatabaseAPIQueryVectorCollectionRequest) QueryVectorCollectionRequest(queryVectorCollectionRequest QueryVectorCollectionRequest) AIVectorDatabaseAPIQueryVectorCollectionRequest {
	r.queryVectorCollectionRequest = &queryVectorCollectionRequest
	return r
}

func (r AIVectorDatabaseAPIQueryVectorCollectionRequest) Execute() (*QueryVectorCollection200Response, *http.Response, error) {
	return r.ApiService.QueryVectorCollectionExecute(r)
}

/*
QueryVectorCollection Semantic Search Query

Performs semantic search on a collection using vector similarity. Returns the most relevant documents based on meaning, not keyword matching.
     *
     * **Three Search Modes:**
     *
     * 1. **Text Query** - Provide `query` string, server generates embedding
     *    - Query text is embedded using the collection's embedding model
     *    - Embeddings are cached for repeated queries
     *
     * 2. **Vector Query** - Provide pre-computed `vector` array
     *    - Skip embedding generation (faster)
     *    - Useful when you've already embedded the query elsewhere
     *    - Vector dimension must match collection (e.g., 1024 for Titan v2)
     *
     * 3. **Metadata List** - Set `listByMetadata: true` with `filter`
     *    - Skip semantic search entirely
     *    - Return all documents matching the filter
     *    - Supports cursor-based pagination for large datasets
     *    - Results ordered by sortBy/sortOrder (default: created_at DESC)
     *
     * **Filtering:**
     * - `filter.exact`: Exact match on metadata fields (AND logic)
     * - `filter.contains`: Array contains filter for tags (ANY match)
     * - Filters can be combined with semantic search or used alone with listByMetadata
     *
     * **Pagination (listByMetadata mode only):**
     * - Use `cursor` from previous response's `nextCursor` to get next page
     * - Uses keyset pagination for efficient traversal of large datasets
     * - Control sort with `sortBy` and `sortOrder`
     *
     * **Use Cases:**
     * - Find relevant documentation for user questions
     * - Power RAG (Retrieval Augmented Generation) in AI assistants
     * - Semantic search across knowledge bases
     * - List all artifacts by building/worker/tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param collectionId The collection ID
 @return AIVectorDatabaseAPIQueryVectorCollectionRequest
*/
func (a *AIVectorDatabaseAPIService) QueryVectorCollection(ctx context.Context, organisation string, collectionId string) AIVectorDatabaseAPIQueryVectorCollectionRequest {
	return AIVectorDatabaseAPIQueryVectorCollectionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return QueryVectorCollection200Response
func (a *AIVectorDatabaseAPIService) QueryVectorCollectionExecute(r AIVectorDatabaseAPIQueryVectorCollectionRequest) (*QueryVectorCollection200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryVectorCollection200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIVectorDatabaseAPIService.QueryVectorCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/vector-db/collections/{collectionId}/query"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryVectorCollectionRequest == nil {
		return localVarReturnValue, nil, reportError("queryVectorCollectionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryVectorCollectionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIVectorDatabaseAPIUploadVectorDocumentsRequest struct {
	ctx context.Context
	ApiService AIVectorDatabaseAPI
	organisation string
	collectionId string
	uploadVectorDocumentsRequest *UploadVectorDocumentsRequest
}

func (r AIVectorDatabaseAPIUploadVectorDocumentsRequest) UploadVectorDocumentsRequest(uploadVectorDocumentsRequest UploadVectorDocumentsRequest) AIVectorDatabaseAPIUploadVectorDocumentsRequest {
	r.uploadVectorDocumentsRequest = &uploadVectorDocumentsRequest
	return r
}

func (r AIVectorDatabaseAPIUploadVectorDocumentsRequest) Execute() (*UploadVectorDocuments200Response, *http.Response, error) {
	return r.ApiService.UploadVectorDocumentsExecute(r)
}

/*
UploadVectorDocuments Upload Documents to Collection

Uploads documents to a vector database collection with automatic embedding generation. Documents are chunked (if needed), embedded using the collection's embedding model, and stored.
     *
     * **Supported Content:**
     * - Plain text content
     * - URLs to fetch content from
     * - Markdown documents
     *
     * **Metadata:**
     * Each document can include metadata (title, source_url, section, tags) that is returned with search results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param collectionId The collection ID
 @return AIVectorDatabaseAPIUploadVectorDocumentsRequest
*/
func (a *AIVectorDatabaseAPIService) UploadVectorDocuments(ctx context.Context, organisation string, collectionId string) AIVectorDatabaseAPIUploadVectorDocumentsRequest {
	return AIVectorDatabaseAPIUploadVectorDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return UploadVectorDocuments200Response
func (a *AIVectorDatabaseAPIService) UploadVectorDocumentsExecute(r AIVectorDatabaseAPIUploadVectorDocumentsRequest) (*UploadVectorDocuments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadVectorDocuments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIVectorDatabaseAPIService.UploadVectorDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/vector-db/collections/{collectionId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uploadVectorDocumentsRequest == nil {
		return localVarReturnValue, nil, reportError("uploadVectorDocumentsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.uploadVectorDocumentsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

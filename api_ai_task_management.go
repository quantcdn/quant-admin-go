/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.9.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AITaskManagementAPI interface {

	/*
	CreateTask Create a new task

	Creates a new task for multi-agent coordination and workflow orchestration.
     *
     * **Key Features:**
     * - **Persistent State**: Tasks survive across conversations and sessions
     * - **Agent Assignment**: Pre-assign tasks to specific agents
     * - **Task Lists**: Group related tasks using taskListId (implicit - no need to create lists first)
     * - **Dependencies**: Define task dependencies for workflow orchestration
     * - **Metadata**: Store flexible JSON metadata for task-specific data
     * - **Progress Tracking**: Track progress from 0.0 to 1.0
     *
     * **Use Cases:**
     * - Break down complex requests into manageable steps
     * - Assign work to specialized agents
     * - Track long-running operations
     * - Coordinate multi-agent workflows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AITaskManagementAPICreateTaskRequest
	*/
	CreateTask(ctx context.Context, organisation string) AITaskManagementAPICreateTaskRequest

	// CreateTaskExecute executes the request
	//  @return CreateTask201Response
	CreateTaskExecute(r AITaskManagementAPICreateTaskRequest) (*CreateTask201Response, *http.Response, error)

	/*
	DeleteTask Delete a task

	Permanently deletes a task. This action cannot be undone.
     *
     * **Dependency Protection:**
     * By default, deletion is blocked if other tasks depend on this task (TASK_HAS_DEPENDENTS error).
     * This prevents breaking workflows.
     *
     * **Cascade Delete:**
     * Use `?cascade=true` to delete the task AND all tasks that depend on it recursively.
     * Useful for cleaning up entire dependency chains.
     *
     * **Examples:**
     * - DELETE /tasks/{id} - Deletes task if no dependents, otherwise returns 409 error
     * - DELETE /tasks/{id}?cascade=true - Deletes task and all dependent tasks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param taskId The task UUID
	@return AITaskManagementAPIDeleteTaskRequest
	*/
	DeleteTask(ctx context.Context, organisation string, taskId string) AITaskManagementAPIDeleteTaskRequest

	// DeleteTaskExecute executes the request
	//  @return DeleteTask200Response
	DeleteTaskExecute(r AITaskManagementAPIDeleteTaskRequest) (*DeleteTask200Response, *http.Response, error)

	/*
	GetDependencyGraph Get dependency graph for a task list

	Returns the full dependency graph for all tasks in a task list.
     *
     * **Use Cases:**
     * - Visualize task dependencies in a UI (DAG diagram)
     * - Analyze workflow structure and critical paths
     * - Find starting tasks (roots) and terminal tasks (leaves)
     * - Plan parallel execution by identifying independent task groups
     *
     * **Response Structure:**
     * - `taskCount`: Total number of tasks in the list
     * - `roots`: Task IDs with no dependencies (starting points)
     * - `leaves`: Task IDs with no dependents (terminal tasks)
     * - `graph`: Adjacency list with each task's dependencies and dependents

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param taskListId The task list ID to get the dependency graph for
	@return AITaskManagementAPIGetDependencyGraphRequest
	*/
	GetDependencyGraph(ctx context.Context, organisation string, taskListId string) AITaskManagementAPIGetDependencyGraphRequest

	// GetDependencyGraphExecute executes the request
	//  @return GetDependencyGraph200Response
	GetDependencyGraphExecute(r AITaskManagementAPIGetDependencyGraphRequest) (*GetDependencyGraph200Response, *http.Response, error)

	/*
	GetTask Get task details

	Retrieves detailed information about a specific task including status, progress, dependencies, and results.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param taskId The task UUID
	@return AITaskManagementAPIGetTaskRequest
	*/
	GetTask(ctx context.Context, organisation string, taskId string) AITaskManagementAPIGetTaskRequest

	// GetTaskExecute executes the request
	//  @return GetTask200Response
	GetTaskExecute(r AITaskManagementAPIGetTaskRequest) (*GetTask200Response, *http.Response, error)

	/*
	ListTasks List tasks with optional filtering

	Lists tasks for an organization with optional filtering. Filters can be combined for powerful queries.
     *
     * **Filter Examples:**
     * - All tasks in a list: ?taskListId=world-1
     * - Pending tasks in a list: ?taskListId=world-1&status=pending
     * - Tasks assigned to an agent: ?assignedAgentId=agent-code-reviewer
     * - Combined: ?taskListId=world-1&status=in_progress&assignedAgentId=agent-1
     *
     * **Reverse Dependency Lookup:**
     * Use `dependsOn` to find tasks that depend on a specific task (waiting for it to complete):
     * - ?dependsOn=task-123 - Returns task IDs only (lightweight)
     * - ?dependsOn=task-123&includeDetails=true - Returns full task objects
     * - ?dependsOn=task-123&status=pending - Pending tasks waiting for task-123
     *
     * **Ordering:**
     * Tasks are returned in reverse chronological order (most recent first).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AITaskManagementAPIListTasksRequest
	*/
	ListTasks(ctx context.Context, organisation string) AITaskManagementAPIListTasksRequest

	// ListTasksExecute executes the request
	//  @return ListTasks200Response
	ListTasksExecute(r AITaskManagementAPIListTasksRequest) (*ListTasks200Response, *http.Response, error)

	/*
	UpdateTask Update a task

	Updates an existing task. All fields are optional - only provided fields will be updated.
     *
     * **Status Transitions:**
     * - Changing from **pending** to **in_progress** automatically sets startedAt timestamp
     * - Changing to **completed**, **failed**, or **cancelled** automatically sets completedAt timestamp
     * - Changing to **blocked** automatically sets blockedAt timestamp
     * - Changing from **blocked** to **in_progress** or **pending** clears blocked fields
     * - Completed tasks get a 30-day TTL for automatic cleanup
     *
     * **Progress Updates:**
     * - Update progress (0.0 to 1.0) to track completion percentage
     * - Update progressMessage for human-readable status updates
     * - Set result object when task completes successfully
     * - Set error string when task fails
     * - Set blockedReason and blockedByTaskIds when blocking a task

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param taskId The task UUID
	@return AITaskManagementAPIUpdateTaskRequest
	*/
	UpdateTask(ctx context.Context, organisation string, taskId string) AITaskManagementAPIUpdateTaskRequest

	// UpdateTaskExecute executes the request
	//  @return UpdateTask200Response
	UpdateTaskExecute(r AITaskManagementAPIUpdateTaskRequest) (*UpdateTask200Response, *http.Response, error)
}

// AITaskManagementAPIService AITaskManagementAPI service
type AITaskManagementAPIService service

type AITaskManagementAPICreateTaskRequest struct {
	ctx context.Context
	ApiService AITaskManagementAPI
	organisation string
	createTaskRequest *CreateTaskRequest
}

func (r AITaskManagementAPICreateTaskRequest) CreateTaskRequest(createTaskRequest CreateTaskRequest) AITaskManagementAPICreateTaskRequest {
	r.createTaskRequest = &createTaskRequest
	return r
}

func (r AITaskManagementAPICreateTaskRequest) Execute() (*CreateTask201Response, *http.Response, error) {
	return r.ApiService.CreateTaskExecute(r)
}

/*
CreateTask Create a new task

Creates a new task for multi-agent coordination and workflow orchestration.
     *
     * **Key Features:**
     * - **Persistent State**: Tasks survive across conversations and sessions
     * - **Agent Assignment**: Pre-assign tasks to specific agents
     * - **Task Lists**: Group related tasks using taskListId (implicit - no need to create lists first)
     * - **Dependencies**: Define task dependencies for workflow orchestration
     * - **Metadata**: Store flexible JSON metadata for task-specific data
     * - **Progress Tracking**: Track progress from 0.0 to 1.0
     *
     * **Use Cases:**
     * - Break down complex requests into manageable steps
     * - Assign work to specialized agents
     * - Track long-running operations
     * - Coordinate multi-agent workflows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AITaskManagementAPICreateTaskRequest
*/
func (a *AITaskManagementAPIService) CreateTask(ctx context.Context, organisation string) AITaskManagementAPICreateTaskRequest {
	return AITaskManagementAPICreateTaskRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return CreateTask201Response
func (a *AITaskManagementAPIService) CreateTaskExecute(r AITaskManagementAPICreateTaskRequest) (*CreateTask201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTask201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AITaskManagementAPIService.CreateTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTaskRequest == nil {
		return localVarReturnValue, nil, reportError("createTaskRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTaskRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AITaskManagementAPIDeleteTaskRequest struct {
	ctx context.Context
	ApiService AITaskManagementAPI
	organisation string
	taskId string
	cascade *bool
}

// If true, delete task and all dependent tasks recursively
func (r AITaskManagementAPIDeleteTaskRequest) Cascade(cascade bool) AITaskManagementAPIDeleteTaskRequest {
	r.cascade = &cascade
	return r
}

func (r AITaskManagementAPIDeleteTaskRequest) Execute() (*DeleteTask200Response, *http.Response, error) {
	return r.ApiService.DeleteTaskExecute(r)
}

/*
DeleteTask Delete a task

Permanently deletes a task. This action cannot be undone.
     *
     * **Dependency Protection:**
     * By default, deletion is blocked if other tasks depend on this task (TASK_HAS_DEPENDENTS error).
     * This prevents breaking workflows.
     *
     * **Cascade Delete:**
     * Use `?cascade=true` to delete the task AND all tasks that depend on it recursively.
     * Useful for cleaning up entire dependency chains.
     *
     * **Examples:**
     * - DELETE /tasks/{id} - Deletes task if no dependents, otherwise returns 409 error
     * - DELETE /tasks/{id}?cascade=true - Deletes task and all dependent tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param taskId The task UUID
 @return AITaskManagementAPIDeleteTaskRequest
*/
func (a *AITaskManagementAPIService) DeleteTask(ctx context.Context, organisation string, taskId string) AITaskManagementAPIDeleteTaskRequest {
	return AITaskManagementAPIDeleteTaskRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return DeleteTask200Response
func (a *AITaskManagementAPIService) DeleteTaskExecute(r AITaskManagementAPIDeleteTaskRequest) (*DeleteTask200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteTask200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AITaskManagementAPIService.DeleteTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tasks/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cascade != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cascade", r.cascade, "form", "")
	} else {
		var defaultValue bool = false
		r.cascade = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v DeleteTask409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AITaskManagementAPIGetDependencyGraphRequest struct {
	ctx context.Context
	ApiService AITaskManagementAPI
	organisation string
	taskListId string
}

func (r AITaskManagementAPIGetDependencyGraphRequest) Execute() (*GetDependencyGraph200Response, *http.Response, error) {
	return r.ApiService.GetDependencyGraphExecute(r)
}

/*
GetDependencyGraph Get dependency graph for a task list

Returns the full dependency graph for all tasks in a task list.
     *
     * **Use Cases:**
     * - Visualize task dependencies in a UI (DAG diagram)
     * - Analyze workflow structure and critical paths
     * - Find starting tasks (roots) and terminal tasks (leaves)
     * - Plan parallel execution by identifying independent task groups
     *
     * **Response Structure:**
     * - `taskCount`: Total number of tasks in the list
     * - `roots`: Task IDs with no dependencies (starting points)
     * - `leaves`: Task IDs with no dependents (terminal tasks)
     * - `graph`: Adjacency list with each task's dependencies and dependents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param taskListId The task list ID to get the dependency graph for
 @return AITaskManagementAPIGetDependencyGraphRequest
*/
func (a *AITaskManagementAPIService) GetDependencyGraph(ctx context.Context, organisation string, taskListId string) AITaskManagementAPIGetDependencyGraphRequest {
	return AITaskManagementAPIGetDependencyGraphRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		taskListId: taskListId,
	}
}

// Execute executes the request
//  @return GetDependencyGraph200Response
func (a *AITaskManagementAPIService) GetDependencyGraphExecute(r AITaskManagementAPIGetDependencyGraphRequest) (*GetDependencyGraph200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDependencyGraph200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AITaskManagementAPIService.GetDependencyGraph")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tasks/{taskListId}/dependency-graph"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskListId"+"}", url.PathEscape(parameterValueToString(r.taskListId, "taskListId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AITaskManagementAPIGetTaskRequest struct {
	ctx context.Context
	ApiService AITaskManagementAPI
	organisation string
	taskId string
}

func (r AITaskManagementAPIGetTaskRequest) Execute() (*GetTask200Response, *http.Response, error) {
	return r.ApiService.GetTaskExecute(r)
}

/*
GetTask Get task details

Retrieves detailed information about a specific task including status, progress, dependencies, and results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param taskId The task UUID
 @return AITaskManagementAPIGetTaskRequest
*/
func (a *AITaskManagementAPIService) GetTask(ctx context.Context, organisation string, taskId string) AITaskManagementAPIGetTaskRequest {
	return AITaskManagementAPIGetTaskRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return GetTask200Response
func (a *AITaskManagementAPIService) GetTaskExecute(r AITaskManagementAPIGetTaskRequest) (*GetTask200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTask200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AITaskManagementAPIService.GetTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tasks/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AITaskManagementAPIListTasksRequest struct {
	ctx context.Context
	ApiService AITaskManagementAPI
	organisation string
	taskListId *string
	status *string
	assignedAgentId *string
	limit *int32
	dependsOn *string
	includeDetails *bool
}

// Filter tasks by task list ID. Task lists are implicit groupings - any string can be used.
func (r AITaskManagementAPIListTasksRequest) TaskListId(taskListId string) AITaskManagementAPIListTasksRequest {
	r.taskListId = &taskListId
	return r
}

// Filter tasks by status
func (r AITaskManagementAPIListTasksRequest) Status(status string) AITaskManagementAPIListTasksRequest {
	r.status = &status
	return r
}

// Filter tasks by assigned agent ID
func (r AITaskManagementAPIListTasksRequest) AssignedAgentId(assignedAgentId string) AITaskManagementAPIListTasksRequest {
	r.assignedAgentId = &assignedAgentId
	return r
}

// Maximum number of tasks to return (default 50, max 100)
func (r AITaskManagementAPIListTasksRequest) Limit(limit int32) AITaskManagementAPIListTasksRequest {
	r.limit = &limit
	return r
}

// Reverse lookup: find tasks that depend on this task ID. Returns tasks waiting for the specified task to complete.
func (r AITaskManagementAPIListTasksRequest) DependsOn(dependsOn string) AITaskManagementAPIListTasksRequest {
	r.dependsOn = &dependsOn
	return r
}

// When using dependsOn, return full task objects in addition to IDs. Default false (IDs only for lightweight responses).
func (r AITaskManagementAPIListTasksRequest) IncludeDetails(includeDetails bool) AITaskManagementAPIListTasksRequest {
	r.includeDetails = &includeDetails
	return r
}

func (r AITaskManagementAPIListTasksRequest) Execute() (*ListTasks200Response, *http.Response, error) {
	return r.ApiService.ListTasksExecute(r)
}

/*
ListTasks List tasks with optional filtering

Lists tasks for an organization with optional filtering. Filters can be combined for powerful queries.
     *
     * **Filter Examples:**
     * - All tasks in a list: ?taskListId=world-1
     * - Pending tasks in a list: ?taskListId=world-1&status=pending
     * - Tasks assigned to an agent: ?assignedAgentId=agent-code-reviewer
     * - Combined: ?taskListId=world-1&status=in_progress&assignedAgentId=agent-1
     *
     * **Reverse Dependency Lookup:**
     * Use `dependsOn` to find tasks that depend on a specific task (waiting for it to complete):
     * - ?dependsOn=task-123 - Returns task IDs only (lightweight)
     * - ?dependsOn=task-123&includeDetails=true - Returns full task objects
     * - ?dependsOn=task-123&status=pending - Pending tasks waiting for task-123
     *
     * **Ordering:**
     * Tasks are returned in reverse chronological order (most recent first).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AITaskManagementAPIListTasksRequest
*/
func (a *AITaskManagementAPIService) ListTasks(ctx context.Context, organisation string) AITaskManagementAPIListTasksRequest {
	return AITaskManagementAPIListTasksRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListTasks200Response
func (a *AITaskManagementAPIService) ListTasksExecute(r AITaskManagementAPIListTasksRequest) (*ListTasks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTasks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AITaskManagementAPIService.ListTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taskListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskListId", r.taskListId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.assignedAgentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedAgentId", r.assignedAgentId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.dependsOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dependsOn", r.dependsOn, "form", "")
	}
	if r.includeDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDetails", r.includeDetails, "form", "")
	} else {
		var defaultValue bool = false
		r.includeDetails = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AITaskManagementAPIUpdateTaskRequest struct {
	ctx context.Context
	ApiService AITaskManagementAPI
	organisation string
	taskId string
	updateTaskRequest *UpdateTaskRequest
}

func (r AITaskManagementAPIUpdateTaskRequest) UpdateTaskRequest(updateTaskRequest UpdateTaskRequest) AITaskManagementAPIUpdateTaskRequest {
	r.updateTaskRequest = &updateTaskRequest
	return r
}

func (r AITaskManagementAPIUpdateTaskRequest) Execute() (*UpdateTask200Response, *http.Response, error) {
	return r.ApiService.UpdateTaskExecute(r)
}

/*
UpdateTask Update a task

Updates an existing task. All fields are optional - only provided fields will be updated.
     *
     * **Status Transitions:**
     * - Changing from **pending** to **in_progress** automatically sets startedAt timestamp
     * - Changing to **completed**, **failed**, or **cancelled** automatically sets completedAt timestamp
     * - Changing to **blocked** automatically sets blockedAt timestamp
     * - Changing from **blocked** to **in_progress** or **pending** clears blocked fields
     * - Completed tasks get a 30-day TTL for automatic cleanup
     *
     * **Progress Updates:**
     * - Update progress (0.0 to 1.0) to track completion percentage
     * - Update progressMessage for human-readable status updates
     * - Set result object when task completes successfully
     * - Set error string when task fails
     * - Set blockedReason and blockedByTaskIds when blocking a task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param taskId The task UUID
 @return AITaskManagementAPIUpdateTaskRequest
*/
func (a *AITaskManagementAPIService) UpdateTask(ctx context.Context, organisation string, taskId string) AITaskManagementAPIUpdateTaskRequest {
	return AITaskManagementAPIUpdateTaskRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return UpdateTask200Response
func (a *AITaskManagementAPIService) UpdateTaskExecute(r AITaskManagementAPIUpdateTaskRequest) (*UpdateTask200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateTask200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AITaskManagementAPIService.UpdateTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tasks/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateTaskRequest == nil {
		return localVarReturnValue, nil, reportError("updateTaskRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateTaskRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

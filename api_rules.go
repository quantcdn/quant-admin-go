/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.8.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type RulesAPI interface {

	/*
	RulesAuthCreate Create an authentication rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesAuthCreateRequest
	*/
	RulesAuthCreate(ctx context.Context, organization string, project string) RulesAPIRulesAuthCreateRequest

	// RulesAuthCreateExecute executes the request
	//  @return V2RuleAuth
	RulesAuthCreateExecute(r RulesAPIRulesAuthCreateRequest) (*V2RuleAuth, *http.Response, error)

	/*
	RulesAuthDelete Delete an authentication rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesAuthDeleteRequest
	*/
	RulesAuthDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesAuthDeleteRequest

	// RulesAuthDeleteExecute executes the request
	RulesAuthDeleteExecute(r RulesAPIRulesAuthDeleteRequest) (*http.Response, error)

	/*
	RulesAuthList List authentication rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesAuthListRequest
	*/
	RulesAuthList(ctx context.Context, organization string, project string) RulesAPIRulesAuthListRequest

	// RulesAuthListExecute executes the request
	//  @return []V2RuleAuth
	RulesAuthListExecute(r RulesAPIRulesAuthListRequest) ([]V2RuleAuth, *http.Response, error)

	/*
	RulesAuthRead Get details of an authentication rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesAuthReadRequest
	*/
	RulesAuthRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesAuthReadRequest

	// RulesAuthReadExecute executes the request
	//  @return V2RuleAuth
	RulesAuthReadExecute(r RulesAPIRulesAuthReadRequest) (*V2RuleAuth, *http.Response, error)

	/*
	RulesAuthUpdate Update an authentication rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesAuthUpdateRequest
	*/
	RulesAuthUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesAuthUpdateRequest

	// RulesAuthUpdateExecute executes the request
	//  @return V2RuleAuth
	RulesAuthUpdateExecute(r RulesAPIRulesAuthUpdateRequest) (*V2RuleAuth, *http.Response, error)

	/*
	RulesBotChallengeCreate Create a bot challenge rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesBotChallengeCreateRequest
	*/
	RulesBotChallengeCreate(ctx context.Context, organization string, project string) RulesAPIRulesBotChallengeCreateRequest

	// RulesBotChallengeCreateExecute executes the request
	//  @return V2RuleBotChallenge
	RulesBotChallengeCreateExecute(r RulesAPIRulesBotChallengeCreateRequest) (*V2RuleBotChallenge, *http.Response, error)

	/*
	RulesBotChallengeDelete Delete a bot challenge rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesBotChallengeDeleteRequest
	*/
	RulesBotChallengeDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesBotChallengeDeleteRequest

	// RulesBotChallengeDeleteExecute executes the request
	RulesBotChallengeDeleteExecute(r RulesAPIRulesBotChallengeDeleteRequest) (*http.Response, error)

	/*
	RulesBotChallengeList List bot challenge rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesBotChallengeListRequest
	*/
	RulesBotChallengeList(ctx context.Context, organization string, project string) RulesAPIRulesBotChallengeListRequest

	// RulesBotChallengeListExecute executes the request
	//  @return []V2RuleBotChallenge
	RulesBotChallengeListExecute(r RulesAPIRulesBotChallengeListRequest) ([]V2RuleBotChallenge, *http.Response, error)

	/*
	RulesBotChallengeRead Get details of a bot challenge rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesBotChallengeReadRequest
	*/
	RulesBotChallengeRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesBotChallengeReadRequest

	// RulesBotChallengeReadExecute executes the request
	//  @return V2RuleBotChallenge
	RulesBotChallengeReadExecute(r RulesAPIRulesBotChallengeReadRequest) (*V2RuleBotChallenge, *http.Response, error)

	/*
	RulesBotChallengeUpdate Update a bot challenge rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesBotChallengeUpdateRequest
	*/
	RulesBotChallengeUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesBotChallengeUpdateRequest

	// RulesBotChallengeUpdateExecute executes the request
	//  @return V2RuleBotChallenge
	RulesBotChallengeUpdateExecute(r RulesAPIRulesBotChallengeUpdateRequest) (*V2RuleBotChallenge, *http.Response, error)

	/*
	RulesContentFilterCreate Create a content filter rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesContentFilterCreateRequest
	*/
	RulesContentFilterCreate(ctx context.Context, organization string, project string) RulesAPIRulesContentFilterCreateRequest

	// RulesContentFilterCreateExecute executes the request
	//  @return V2RuleContentFilter
	RulesContentFilterCreateExecute(r RulesAPIRulesContentFilterCreateRequest) (*V2RuleContentFilter, *http.Response, error)

	/*
	RulesContentFilterDelete Delete a content filter rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesContentFilterDeleteRequest
	*/
	RulesContentFilterDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesContentFilterDeleteRequest

	// RulesContentFilterDeleteExecute executes the request
	RulesContentFilterDeleteExecute(r RulesAPIRulesContentFilterDeleteRequest) (*http.Response, error)

	/*
	RulesContentFilterList List content filter rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesContentFilterListRequest
	*/
	RulesContentFilterList(ctx context.Context, organization string, project string) RulesAPIRulesContentFilterListRequest

	// RulesContentFilterListExecute executes the request
	//  @return []V2RuleContentFilter
	RulesContentFilterListExecute(r RulesAPIRulesContentFilterListRequest) ([]V2RuleContentFilter, *http.Response, error)

	/*
	RulesContentFilterRead Get details of a content filter rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesContentFilterReadRequest
	*/
	RulesContentFilterRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesContentFilterReadRequest

	// RulesContentFilterReadExecute executes the request
	//  @return V2RuleContentFilter
	RulesContentFilterReadExecute(r RulesAPIRulesContentFilterReadRequest) (*V2RuleContentFilter, *http.Response, error)

	/*
	RulesContentFilterUpdate Update a content filter rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesContentFilterUpdateRequest
	*/
	RulesContentFilterUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesContentFilterUpdateRequest

	// RulesContentFilterUpdateExecute executes the request
	//  @return V2RuleContentFilter
	RulesContentFilterUpdateExecute(r RulesAPIRulesContentFilterUpdateRequest) (*V2RuleContentFilter, *http.Response, error)

	/*
	RulesCustomResponseCreate Create a custom response rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesCustomResponseCreateRequest
	*/
	RulesCustomResponseCreate(ctx context.Context, organization string, project string) RulesAPIRulesCustomResponseCreateRequest

	// RulesCustomResponseCreateExecute executes the request
	//  @return V2RuleCustomResponse
	RulesCustomResponseCreateExecute(r RulesAPIRulesCustomResponseCreateRequest) (*V2RuleCustomResponse, *http.Response, error)

	/*
	RulesCustomResponseDelete Delete a custom response rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesCustomResponseDeleteRequest
	*/
	RulesCustomResponseDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesCustomResponseDeleteRequest

	// RulesCustomResponseDeleteExecute executes the request
	RulesCustomResponseDeleteExecute(r RulesAPIRulesCustomResponseDeleteRequest) (*http.Response, error)

	/*
	RulesCustomResponseList List custom response rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesCustomResponseListRequest
	*/
	RulesCustomResponseList(ctx context.Context, organization string, project string) RulesAPIRulesCustomResponseListRequest

	// RulesCustomResponseListExecute executes the request
	//  @return []V2RuleCustomResponse
	RulesCustomResponseListExecute(r RulesAPIRulesCustomResponseListRequest) ([]V2RuleCustomResponse, *http.Response, error)

	/*
	RulesCustomResponseRead Get details of a custom response rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesCustomResponseReadRequest
	*/
	RulesCustomResponseRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesCustomResponseReadRequest

	// RulesCustomResponseReadExecute executes the request
	//  @return V2RuleCustomResponse
	RulesCustomResponseReadExecute(r RulesAPIRulesCustomResponseReadRequest) (*V2RuleCustomResponse, *http.Response, error)

	/*
	RulesCustomResponseUpdate Update a custom response rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesCustomResponseUpdateRequest
	*/
	RulesCustomResponseUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesCustomResponseUpdateRequest

	// RulesCustomResponseUpdateExecute executes the request
	//  @return V2RuleCustomResponse
	RulesCustomResponseUpdateExecute(r RulesAPIRulesCustomResponseUpdateRequest) (*V2RuleCustomResponse, *http.Response, error)

	/*
	RulesFunctionCreate Create an edge function rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesFunctionCreateRequest
	*/
	RulesFunctionCreate(ctx context.Context, organization string, project string) RulesAPIRulesFunctionCreateRequest

	// RulesFunctionCreateExecute executes the request
	//  @return V2RuleFunction
	RulesFunctionCreateExecute(r RulesAPIRulesFunctionCreateRequest) (*V2RuleFunction, *http.Response, error)

	/*
	RulesFunctionDelete Delete an edge function rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesFunctionDeleteRequest
	*/
	RulesFunctionDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesFunctionDeleteRequest

	// RulesFunctionDeleteExecute executes the request
	RulesFunctionDeleteExecute(r RulesAPIRulesFunctionDeleteRequest) (*http.Response, error)

	/*
	RulesFunctionList List edge function rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesFunctionListRequest
	*/
	RulesFunctionList(ctx context.Context, organization string, project string) RulesAPIRulesFunctionListRequest

	// RulesFunctionListExecute executes the request
	//  @return []V2RuleFunction
	RulesFunctionListExecute(r RulesAPIRulesFunctionListRequest) ([]V2RuleFunction, *http.Response, error)

	/*
	RulesFunctionRead Get details of an edge function rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesFunctionReadRequest
	*/
	RulesFunctionRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesFunctionReadRequest

	// RulesFunctionReadExecute executes the request
	//  @return V2RuleFunction
	RulesFunctionReadExecute(r RulesAPIRulesFunctionReadRequest) (*V2RuleFunction, *http.Response, error)

	/*
	RulesFunctionUpdate Update an edge function rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesFunctionUpdateRequest
	*/
	RulesFunctionUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesFunctionUpdateRequest

	// RulesFunctionUpdateExecute executes the request
	//  @return V2RuleFunction
	RulesFunctionUpdateExecute(r RulesAPIRulesFunctionUpdateRequest) (*V2RuleFunction, *http.Response, error)

	/*
	RulesHeadersCreate Create a header rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesHeadersCreateRequest
	*/
	RulesHeadersCreate(ctx context.Context, organization string, project string) RulesAPIRulesHeadersCreateRequest

	// RulesHeadersCreateExecute executes the request
	//  @return V2RuleHeader
	RulesHeadersCreateExecute(r RulesAPIRulesHeadersCreateRequest) (*V2RuleHeader, *http.Response, error)

	/*
	RulesHeadersDelete Delete a header rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesHeadersDeleteRequest
	*/
	RulesHeadersDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesHeadersDeleteRequest

	// RulesHeadersDeleteExecute executes the request
	RulesHeadersDeleteExecute(r RulesAPIRulesHeadersDeleteRequest) (*http.Response, error)

	/*
	RulesHeadersList List header rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesHeadersListRequest
	*/
	RulesHeadersList(ctx context.Context, organization string, project string) RulesAPIRulesHeadersListRequest

	// RulesHeadersListExecute executes the request
	//  @return []V2RuleHeader
	RulesHeadersListExecute(r RulesAPIRulesHeadersListRequest) ([]V2RuleHeader, *http.Response, error)

	/*
	RulesHeadersRead Get details of a header rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesHeadersReadRequest
	*/
	RulesHeadersRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesHeadersReadRequest

	// RulesHeadersReadExecute executes the request
	//  @return V2RuleHeader
	RulesHeadersReadExecute(r RulesAPIRulesHeadersReadRequest) (*V2RuleHeader, *http.Response, error)

	/*
	RulesHeadersUpdate Update a header rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesHeadersUpdateRequest
	*/
	RulesHeadersUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesHeadersUpdateRequest

	// RulesHeadersUpdateExecute executes the request
	//  @return V2RuleHeader
	RulesHeadersUpdateExecute(r RulesAPIRulesHeadersUpdateRequest) (*V2RuleHeader, *http.Response, error)

	/*
	RulesProxyCreate Create a proxy rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@return RulesAPIRulesProxyCreateRequest
	*/
	RulesProxyCreate(ctx context.Context, organization string, project string) RulesAPIRulesProxyCreateRequest

	// RulesProxyCreateExecute executes the request
	//  @return V2RuleProxy
	RulesProxyCreateExecute(r RulesAPIRulesProxyCreateRequest) (*V2RuleProxy, *http.Response, error)

	/*
	RulesProxyDelete Delete a proxy rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@param rule
	@return RulesAPIRulesProxyDeleteRequest
	*/
	RulesProxyDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesProxyDeleteRequest

	// RulesProxyDeleteExecute executes the request
	RulesProxyDeleteExecute(r RulesAPIRulesProxyDeleteRequest) (*http.Response, error)

	/*
	RulesProxyList List proxy rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@return RulesAPIRulesProxyListRequest
	*/
	RulesProxyList(ctx context.Context, organization string, project string) RulesAPIRulesProxyListRequest

	// RulesProxyListExecute executes the request
	//  @return []V2RuleProxy
	RulesProxyListExecute(r RulesAPIRulesProxyListRequest) ([]V2RuleProxy, *http.Response, error)

	/*
	RulesProxyRead Get details of a proxy rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@param rule
	@return RulesAPIRulesProxyReadRequest
	*/
	RulesProxyRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesProxyReadRequest

	// RulesProxyReadExecute executes the request
	//  @return V2RuleProxy
	RulesProxyReadExecute(r RulesAPIRulesProxyReadRequest) (*V2RuleProxy, *http.Response, error)

	/*
	RulesProxyUpdate Update a proxy rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@param rule
	@return RulesAPIRulesProxyUpdateRequest
	*/
	RulesProxyUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesProxyUpdateRequest

	// RulesProxyUpdateExecute executes the request
	//  @return V2RuleProxy
	RulesProxyUpdateExecute(r RulesAPIRulesProxyUpdateRequest) (*V2RuleProxy, *http.Response, error)

	/*
	RulesRedirectCreate Create a redirect rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@return RulesAPIRulesRedirectCreateRequest
	*/
	RulesRedirectCreate(ctx context.Context, organization string, project string) RulesAPIRulesRedirectCreateRequest

	// RulesRedirectCreateExecute executes the request
	//  @return V2RuleRedirect
	RulesRedirectCreateExecute(r RulesAPIRulesRedirectCreateRequest) (*V2RuleRedirect, *http.Response, error)

	/*
	RulesRedirectDelete Delete a redirect rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@param rule
	@return RulesAPIRulesRedirectDeleteRequest
	*/
	RulesRedirectDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesRedirectDeleteRequest

	// RulesRedirectDeleteExecute executes the request
	RulesRedirectDeleteExecute(r RulesAPIRulesRedirectDeleteRequest) (*http.Response, error)

	/*
	RulesRedirectList List redirect rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@return RulesAPIRulesRedirectListRequest
	*/
	RulesRedirectList(ctx context.Context, organization string, project string) RulesAPIRulesRedirectListRequest

	// RulesRedirectListExecute executes the request
	//  @return []V2RuleRedirect
	RulesRedirectListExecute(r RulesAPIRulesRedirectListRequest) ([]V2RuleRedirect, *http.Response, error)

	/*
	RulesRedirectRead Get details of a redirect rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@param rule
	@return RulesAPIRulesRedirectReadRequest
	*/
	RulesRedirectRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesRedirectReadRequest

	// RulesRedirectReadExecute executes the request
	//  @return V2RuleRedirect
	RulesRedirectReadExecute(r RulesAPIRulesRedirectReadRequest) (*V2RuleRedirect, *http.Response, error)

	/*
	RulesRedirectUpdate Update a redirect rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization
	@param project
	@param rule
	@return RulesAPIRulesRedirectUpdateRequest
	*/
	RulesRedirectUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesRedirectUpdateRequest

	// RulesRedirectUpdateExecute executes the request
	//  @return V2RuleRedirect
	RulesRedirectUpdateExecute(r RulesAPIRulesRedirectUpdateRequest) (*V2RuleRedirect, *http.Response, error)

	/*
	RulesServeStaticCreate Create a serve static rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesServeStaticCreateRequest
	*/
	RulesServeStaticCreate(ctx context.Context, organization string, project string) RulesAPIRulesServeStaticCreateRequest

	// RulesServeStaticCreateExecute executes the request
	//  @return V2RuleServeStatic
	RulesServeStaticCreateExecute(r RulesAPIRulesServeStaticCreateRequest) (*V2RuleServeStatic, *http.Response, error)

	/*
	RulesServeStaticDelete Delete a serve static rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesServeStaticDeleteRequest
	*/
	RulesServeStaticDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesServeStaticDeleteRequest

	// RulesServeStaticDeleteExecute executes the request
	RulesServeStaticDeleteExecute(r RulesAPIRulesServeStaticDeleteRequest) (*http.Response, error)

	/*
	RulesServeStaticList List serve static rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@return RulesAPIRulesServeStaticListRequest
	*/
	RulesServeStaticList(ctx context.Context, organization string, project string) RulesAPIRulesServeStaticListRequest

	// RulesServeStaticListExecute executes the request
	//  @return []V2RuleServeStatic
	RulesServeStaticListExecute(r RulesAPIRulesServeStaticListRequest) ([]V2RuleServeStatic, *http.Response, error)

	/*
	RulesServeStaticRead Get details of a serve static rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesServeStaticReadRequest
	*/
	RulesServeStaticRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesServeStaticReadRequest

	// RulesServeStaticReadExecute executes the request
	//  @return V2RuleServeStatic
	RulesServeStaticReadExecute(r RulesAPIRulesServeStaticReadRequest) (*V2RuleServeStatic, *http.Response, error)

	/*
	RulesServeStaticUpdate Update a serve static rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization identifier
	@param project Project identifier
	@param rule Rule identifier
	@return RulesAPIRulesServeStaticUpdateRequest
	*/
	RulesServeStaticUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesServeStaticUpdateRequest

	// RulesServeStaticUpdateExecute executes the request
	//  @return V2RuleServeStatic
	RulesServeStaticUpdateExecute(r RulesAPIRulesServeStaticUpdateRequest) (*V2RuleServeStatic, *http.Response, error)
}

// RulesAPIService RulesAPI service
type RulesAPIService service

type RulesAPIRulesAuthCreateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	v2RuleAuthRequest *V2RuleAuthRequest
}

func (r RulesAPIRulesAuthCreateRequest) V2RuleAuthRequest(v2RuleAuthRequest V2RuleAuthRequest) RulesAPIRulesAuthCreateRequest {
	r.v2RuleAuthRequest = &v2RuleAuthRequest
	return r
}

func (r RulesAPIRulesAuthCreateRequest) Execute() (*V2RuleAuth, *http.Response, error) {
	return r.ApiService.RulesAuthCreateExecute(r)
}

/*
RulesAuthCreate Create an authentication rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesAuthCreateRequest
*/
func (a *RulesAPIService) RulesAuthCreate(ctx context.Context, organization string, project string) RulesAPIRulesAuthCreateRequest {
	return RulesAPIRulesAuthCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2RuleAuth
func (a *RulesAPIService) RulesAuthCreateExecute(r RulesAPIRulesAuthCreateRequest) (*V2RuleAuth, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleAuth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesAuthCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/auth"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleAuthRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleAuthRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleAuthRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesAuthDeleteRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesAuthDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RulesAuthDeleteExecute(r)
}

/*
RulesAuthDelete Delete an authentication rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesAuthDeleteRequest
*/
func (a *RulesAPIService) RulesAuthDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesAuthDeleteRequest {
	return RulesAPIRulesAuthDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
func (a *RulesAPIService) RulesAuthDeleteExecute(r RulesAPIRulesAuthDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesAuthDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/auth/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RulesAPIRulesAuthListRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
}

func (r RulesAPIRulesAuthListRequest) Execute() ([]V2RuleAuth, *http.Response, error) {
	return r.ApiService.RulesAuthListExecute(r)
}

/*
RulesAuthList List authentication rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesAuthListRequest
*/
func (a *RulesAPIService) RulesAuthList(ctx context.Context, organization string, project string) RulesAPIRulesAuthListRequest {
	return RulesAPIRulesAuthListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2RuleAuth
func (a *RulesAPIService) RulesAuthListExecute(r RulesAPIRulesAuthListRequest) ([]V2RuleAuth, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2RuleAuth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesAuthList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/auth"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesAuthReadRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesAuthReadRequest) Execute() (*V2RuleAuth, *http.Response, error) {
	return r.ApiService.RulesAuthReadExecute(r)
}

/*
RulesAuthRead Get details of an authentication rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesAuthReadRequest
*/
func (a *RulesAPIService) RulesAuthRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesAuthReadRequest {
	return RulesAPIRulesAuthReadRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleAuth
func (a *RulesAPIService) RulesAuthReadExecute(r RulesAPIRulesAuthReadRequest) (*V2RuleAuth, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleAuth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesAuthRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/auth/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesAuthUpdateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
	v2RuleAuthRequest *V2RuleAuthRequest
}

func (r RulesAPIRulesAuthUpdateRequest) V2RuleAuthRequest(v2RuleAuthRequest V2RuleAuthRequest) RulesAPIRulesAuthUpdateRequest {
	r.v2RuleAuthRequest = &v2RuleAuthRequest
	return r
}

func (r RulesAPIRulesAuthUpdateRequest) Execute() (*V2RuleAuth, *http.Response, error) {
	return r.ApiService.RulesAuthUpdateExecute(r)
}

/*
RulesAuthUpdate Update an authentication rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesAuthUpdateRequest
*/
func (a *RulesAPIService) RulesAuthUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesAuthUpdateRequest {
	return RulesAPIRulesAuthUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleAuth
func (a *RulesAPIService) RulesAuthUpdateExecute(r RulesAPIRulesAuthUpdateRequest) (*V2RuleAuth, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleAuth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesAuthUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/auth/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleAuthRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleAuthRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleAuthRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesBotChallengeCreateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	v2RuleBotChallengeRequest *V2RuleBotChallengeRequest
}

func (r RulesAPIRulesBotChallengeCreateRequest) V2RuleBotChallengeRequest(v2RuleBotChallengeRequest V2RuleBotChallengeRequest) RulesAPIRulesBotChallengeCreateRequest {
	r.v2RuleBotChallengeRequest = &v2RuleBotChallengeRequest
	return r
}

func (r RulesAPIRulesBotChallengeCreateRequest) Execute() (*V2RuleBotChallenge, *http.Response, error) {
	return r.ApiService.RulesBotChallengeCreateExecute(r)
}

/*
RulesBotChallengeCreate Create a bot challenge rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesBotChallengeCreateRequest
*/
func (a *RulesAPIService) RulesBotChallengeCreate(ctx context.Context, organization string, project string) RulesAPIRulesBotChallengeCreateRequest {
	return RulesAPIRulesBotChallengeCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2RuleBotChallenge
func (a *RulesAPIService) RulesBotChallengeCreateExecute(r RulesAPIRulesBotChallengeCreateRequest) (*V2RuleBotChallenge, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleBotChallenge
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesBotChallengeCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleBotChallengeRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleBotChallengeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleBotChallengeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesBotChallengeDeleteRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesBotChallengeDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RulesBotChallengeDeleteExecute(r)
}

/*
RulesBotChallengeDelete Delete a bot challenge rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesBotChallengeDeleteRequest
*/
func (a *RulesAPIService) RulesBotChallengeDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesBotChallengeDeleteRequest {
	return RulesAPIRulesBotChallengeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
func (a *RulesAPIService) RulesBotChallengeDeleteExecute(r RulesAPIRulesBotChallengeDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesBotChallengeDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RulesAPIRulesBotChallengeListRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
}

func (r RulesAPIRulesBotChallengeListRequest) Execute() ([]V2RuleBotChallenge, *http.Response, error) {
	return r.ApiService.RulesBotChallengeListExecute(r)
}

/*
RulesBotChallengeList List bot challenge rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesBotChallengeListRequest
*/
func (a *RulesAPIService) RulesBotChallengeList(ctx context.Context, organization string, project string) RulesAPIRulesBotChallengeListRequest {
	return RulesAPIRulesBotChallengeListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2RuleBotChallenge
func (a *RulesAPIService) RulesBotChallengeListExecute(r RulesAPIRulesBotChallengeListRequest) ([]V2RuleBotChallenge, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2RuleBotChallenge
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesBotChallengeList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesBotChallengeReadRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesBotChallengeReadRequest) Execute() (*V2RuleBotChallenge, *http.Response, error) {
	return r.ApiService.RulesBotChallengeReadExecute(r)
}

/*
RulesBotChallengeRead Get details of a bot challenge rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesBotChallengeReadRequest
*/
func (a *RulesAPIService) RulesBotChallengeRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesBotChallengeReadRequest {
	return RulesAPIRulesBotChallengeReadRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleBotChallenge
func (a *RulesAPIService) RulesBotChallengeReadExecute(r RulesAPIRulesBotChallengeReadRequest) (*V2RuleBotChallenge, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleBotChallenge
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesBotChallengeRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesBotChallengeUpdateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
	v2RuleBotChallengeRequest *V2RuleBotChallengeRequest
}

func (r RulesAPIRulesBotChallengeUpdateRequest) V2RuleBotChallengeRequest(v2RuleBotChallengeRequest V2RuleBotChallengeRequest) RulesAPIRulesBotChallengeUpdateRequest {
	r.v2RuleBotChallengeRequest = &v2RuleBotChallengeRequest
	return r
}

func (r RulesAPIRulesBotChallengeUpdateRequest) Execute() (*V2RuleBotChallenge, *http.Response, error) {
	return r.ApiService.RulesBotChallengeUpdateExecute(r)
}

/*
RulesBotChallengeUpdate Update a bot challenge rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesBotChallengeUpdateRequest
*/
func (a *RulesAPIService) RulesBotChallengeUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesBotChallengeUpdateRequest {
	return RulesAPIRulesBotChallengeUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleBotChallenge
func (a *RulesAPIService) RulesBotChallengeUpdateExecute(r RulesAPIRulesBotChallengeUpdateRequest) (*V2RuleBotChallenge, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleBotChallenge
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesBotChallengeUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleBotChallengeRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleBotChallengeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleBotChallengeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesContentFilterCreateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	v2RuleContentFilterRequest *V2RuleContentFilterRequest
}

func (r RulesAPIRulesContentFilterCreateRequest) V2RuleContentFilterRequest(v2RuleContentFilterRequest V2RuleContentFilterRequest) RulesAPIRulesContentFilterCreateRequest {
	r.v2RuleContentFilterRequest = &v2RuleContentFilterRequest
	return r
}

func (r RulesAPIRulesContentFilterCreateRequest) Execute() (*V2RuleContentFilter, *http.Response, error) {
	return r.ApiService.RulesContentFilterCreateExecute(r)
}

/*
RulesContentFilterCreate Create a content filter rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesContentFilterCreateRequest
*/
func (a *RulesAPIService) RulesContentFilterCreate(ctx context.Context, organization string, project string) RulesAPIRulesContentFilterCreateRequest {
	return RulesAPIRulesContentFilterCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2RuleContentFilter
func (a *RulesAPIService) RulesContentFilterCreateExecute(r RulesAPIRulesContentFilterCreateRequest) (*V2RuleContentFilter, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleContentFilter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesContentFilterCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/content-filter"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleContentFilterRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleContentFilterRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleContentFilterRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesContentFilterDeleteRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesContentFilterDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RulesContentFilterDeleteExecute(r)
}

/*
RulesContentFilterDelete Delete a content filter rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesContentFilterDeleteRequest
*/
func (a *RulesAPIService) RulesContentFilterDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesContentFilterDeleteRequest {
	return RulesAPIRulesContentFilterDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
func (a *RulesAPIService) RulesContentFilterDeleteExecute(r RulesAPIRulesContentFilterDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesContentFilterDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/content-filter/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RulesAPIRulesContentFilterListRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
}

func (r RulesAPIRulesContentFilterListRequest) Execute() ([]V2RuleContentFilter, *http.Response, error) {
	return r.ApiService.RulesContentFilterListExecute(r)
}

/*
RulesContentFilterList List content filter rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesContentFilterListRequest
*/
func (a *RulesAPIService) RulesContentFilterList(ctx context.Context, organization string, project string) RulesAPIRulesContentFilterListRequest {
	return RulesAPIRulesContentFilterListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2RuleContentFilter
func (a *RulesAPIService) RulesContentFilterListExecute(r RulesAPIRulesContentFilterListRequest) ([]V2RuleContentFilter, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2RuleContentFilter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesContentFilterList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/content-filter"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesContentFilterReadRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesContentFilterReadRequest) Execute() (*V2RuleContentFilter, *http.Response, error) {
	return r.ApiService.RulesContentFilterReadExecute(r)
}

/*
RulesContentFilterRead Get details of a content filter rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesContentFilterReadRequest
*/
func (a *RulesAPIService) RulesContentFilterRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesContentFilterReadRequest {
	return RulesAPIRulesContentFilterReadRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleContentFilter
func (a *RulesAPIService) RulesContentFilterReadExecute(r RulesAPIRulesContentFilterReadRequest) (*V2RuleContentFilter, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleContentFilter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesContentFilterRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/content-filter/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesContentFilterUpdateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
	v2RuleContentFilterRequest *V2RuleContentFilterRequest
}

func (r RulesAPIRulesContentFilterUpdateRequest) V2RuleContentFilterRequest(v2RuleContentFilterRequest V2RuleContentFilterRequest) RulesAPIRulesContentFilterUpdateRequest {
	r.v2RuleContentFilterRequest = &v2RuleContentFilterRequest
	return r
}

func (r RulesAPIRulesContentFilterUpdateRequest) Execute() (*V2RuleContentFilter, *http.Response, error) {
	return r.ApiService.RulesContentFilterUpdateExecute(r)
}

/*
RulesContentFilterUpdate Update a content filter rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesContentFilterUpdateRequest
*/
func (a *RulesAPIService) RulesContentFilterUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesContentFilterUpdateRequest {
	return RulesAPIRulesContentFilterUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleContentFilter
func (a *RulesAPIService) RulesContentFilterUpdateExecute(r RulesAPIRulesContentFilterUpdateRequest) (*V2RuleContentFilter, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleContentFilter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesContentFilterUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/content-filter/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleContentFilterRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleContentFilterRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleContentFilterRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesCustomResponseCreateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	v2RuleCustomResponseRequest *V2RuleCustomResponseRequest
}

func (r RulesAPIRulesCustomResponseCreateRequest) V2RuleCustomResponseRequest(v2RuleCustomResponseRequest V2RuleCustomResponseRequest) RulesAPIRulesCustomResponseCreateRequest {
	r.v2RuleCustomResponseRequest = &v2RuleCustomResponseRequest
	return r
}

func (r RulesAPIRulesCustomResponseCreateRequest) Execute() (*V2RuleCustomResponse, *http.Response, error) {
	return r.ApiService.RulesCustomResponseCreateExecute(r)
}

/*
RulesCustomResponseCreate Create a custom response rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesCustomResponseCreateRequest
*/
func (a *RulesAPIService) RulesCustomResponseCreate(ctx context.Context, organization string, project string) RulesAPIRulesCustomResponseCreateRequest {
	return RulesAPIRulesCustomResponseCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2RuleCustomResponse
func (a *RulesAPIService) RulesCustomResponseCreateExecute(r RulesAPIRulesCustomResponseCreateRequest) (*V2RuleCustomResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleCustomResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesCustomResponseCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/custom-response"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleCustomResponseRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleCustomResponseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleCustomResponseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesCustomResponseDeleteRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesCustomResponseDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RulesCustomResponseDeleteExecute(r)
}

/*
RulesCustomResponseDelete Delete a custom response rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesCustomResponseDeleteRequest
*/
func (a *RulesAPIService) RulesCustomResponseDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesCustomResponseDeleteRequest {
	return RulesAPIRulesCustomResponseDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
func (a *RulesAPIService) RulesCustomResponseDeleteExecute(r RulesAPIRulesCustomResponseDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesCustomResponseDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/custom-response/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RulesAPIRulesCustomResponseListRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
}

func (r RulesAPIRulesCustomResponseListRequest) Execute() ([]V2RuleCustomResponse, *http.Response, error) {
	return r.ApiService.RulesCustomResponseListExecute(r)
}

/*
RulesCustomResponseList List custom response rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesCustomResponseListRequest
*/
func (a *RulesAPIService) RulesCustomResponseList(ctx context.Context, organization string, project string) RulesAPIRulesCustomResponseListRequest {
	return RulesAPIRulesCustomResponseListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2RuleCustomResponse
func (a *RulesAPIService) RulesCustomResponseListExecute(r RulesAPIRulesCustomResponseListRequest) ([]V2RuleCustomResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2RuleCustomResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesCustomResponseList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/custom-response"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesCustomResponseReadRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesCustomResponseReadRequest) Execute() (*V2RuleCustomResponse, *http.Response, error) {
	return r.ApiService.RulesCustomResponseReadExecute(r)
}

/*
RulesCustomResponseRead Get details of a custom response rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesCustomResponseReadRequest
*/
func (a *RulesAPIService) RulesCustomResponseRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesCustomResponseReadRequest {
	return RulesAPIRulesCustomResponseReadRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleCustomResponse
func (a *RulesAPIService) RulesCustomResponseReadExecute(r RulesAPIRulesCustomResponseReadRequest) (*V2RuleCustomResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleCustomResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesCustomResponseRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/custom-response/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesCustomResponseUpdateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
	v2RuleCustomResponseRequest *V2RuleCustomResponseRequest
}

func (r RulesAPIRulesCustomResponseUpdateRequest) V2RuleCustomResponseRequest(v2RuleCustomResponseRequest V2RuleCustomResponseRequest) RulesAPIRulesCustomResponseUpdateRequest {
	r.v2RuleCustomResponseRequest = &v2RuleCustomResponseRequest
	return r
}

func (r RulesAPIRulesCustomResponseUpdateRequest) Execute() (*V2RuleCustomResponse, *http.Response, error) {
	return r.ApiService.RulesCustomResponseUpdateExecute(r)
}

/*
RulesCustomResponseUpdate Update a custom response rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesCustomResponseUpdateRequest
*/
func (a *RulesAPIService) RulesCustomResponseUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesCustomResponseUpdateRequest {
	return RulesAPIRulesCustomResponseUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleCustomResponse
func (a *RulesAPIService) RulesCustomResponseUpdateExecute(r RulesAPIRulesCustomResponseUpdateRequest) (*V2RuleCustomResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleCustomResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesCustomResponseUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/custom-response/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleCustomResponseRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleCustomResponseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleCustomResponseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesFunctionCreateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	v2RuleFunctionRequest *V2RuleFunctionRequest
}

func (r RulesAPIRulesFunctionCreateRequest) V2RuleFunctionRequest(v2RuleFunctionRequest V2RuleFunctionRequest) RulesAPIRulesFunctionCreateRequest {
	r.v2RuleFunctionRequest = &v2RuleFunctionRequest
	return r
}

func (r RulesAPIRulesFunctionCreateRequest) Execute() (*V2RuleFunction, *http.Response, error) {
	return r.ApiService.RulesFunctionCreateExecute(r)
}

/*
RulesFunctionCreate Create an edge function rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesFunctionCreateRequest
*/
func (a *RulesAPIService) RulesFunctionCreate(ctx context.Context, organization string, project string) RulesAPIRulesFunctionCreateRequest {
	return RulesAPIRulesFunctionCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2RuleFunction
func (a *RulesAPIService) RulesFunctionCreateExecute(r RulesAPIRulesFunctionCreateRequest) (*V2RuleFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesFunctionCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/function"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleFunctionRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleFunctionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleFunctionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesFunctionDeleteRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesFunctionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RulesFunctionDeleteExecute(r)
}

/*
RulesFunctionDelete Delete an edge function rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesFunctionDeleteRequest
*/
func (a *RulesAPIService) RulesFunctionDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesFunctionDeleteRequest {
	return RulesAPIRulesFunctionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
func (a *RulesAPIService) RulesFunctionDeleteExecute(r RulesAPIRulesFunctionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesFunctionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/function/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RulesAPIRulesFunctionListRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
}

func (r RulesAPIRulesFunctionListRequest) Execute() ([]V2RuleFunction, *http.Response, error) {
	return r.ApiService.RulesFunctionListExecute(r)
}

/*
RulesFunctionList List edge function rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesFunctionListRequest
*/
func (a *RulesAPIService) RulesFunctionList(ctx context.Context, organization string, project string) RulesAPIRulesFunctionListRequest {
	return RulesAPIRulesFunctionListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2RuleFunction
func (a *RulesAPIService) RulesFunctionListExecute(r RulesAPIRulesFunctionListRequest) ([]V2RuleFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2RuleFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesFunctionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/function"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesFunctionReadRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesFunctionReadRequest) Execute() (*V2RuleFunction, *http.Response, error) {
	return r.ApiService.RulesFunctionReadExecute(r)
}

/*
RulesFunctionRead Get details of an edge function rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesFunctionReadRequest
*/
func (a *RulesAPIService) RulesFunctionRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesFunctionReadRequest {
	return RulesAPIRulesFunctionReadRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleFunction
func (a *RulesAPIService) RulesFunctionReadExecute(r RulesAPIRulesFunctionReadRequest) (*V2RuleFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesFunctionRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/function/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesFunctionUpdateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
	v2RuleFunctionRequest *V2RuleFunctionRequest
}

func (r RulesAPIRulesFunctionUpdateRequest) V2RuleFunctionRequest(v2RuleFunctionRequest V2RuleFunctionRequest) RulesAPIRulesFunctionUpdateRequest {
	r.v2RuleFunctionRequest = &v2RuleFunctionRequest
	return r
}

func (r RulesAPIRulesFunctionUpdateRequest) Execute() (*V2RuleFunction, *http.Response, error) {
	return r.ApiService.RulesFunctionUpdateExecute(r)
}

/*
RulesFunctionUpdate Update an edge function rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesFunctionUpdateRequest
*/
func (a *RulesAPIService) RulesFunctionUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesFunctionUpdateRequest {
	return RulesAPIRulesFunctionUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleFunction
func (a *RulesAPIService) RulesFunctionUpdateExecute(r RulesAPIRulesFunctionUpdateRequest) (*V2RuleFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesFunctionUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/function/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleFunctionRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleFunctionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleFunctionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesHeadersCreateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	v2RuleHeaderRequest *V2RuleHeaderRequest
}

func (r RulesAPIRulesHeadersCreateRequest) V2RuleHeaderRequest(v2RuleHeaderRequest V2RuleHeaderRequest) RulesAPIRulesHeadersCreateRequest {
	r.v2RuleHeaderRequest = &v2RuleHeaderRequest
	return r
}

func (r RulesAPIRulesHeadersCreateRequest) Execute() (*V2RuleHeader, *http.Response, error) {
	return r.ApiService.RulesHeadersCreateExecute(r)
}

/*
RulesHeadersCreate Create a header rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesHeadersCreateRequest
*/
func (a *RulesAPIService) RulesHeadersCreate(ctx context.Context, organization string, project string) RulesAPIRulesHeadersCreateRequest {
	return RulesAPIRulesHeadersCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2RuleHeader
func (a *RulesAPIService) RulesHeadersCreateExecute(r RulesAPIRulesHeadersCreateRequest) (*V2RuleHeader, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleHeader
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesHeadersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/headers"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleHeaderRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleHeaderRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleHeaderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesHeadersDeleteRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesHeadersDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RulesHeadersDeleteExecute(r)
}

/*
RulesHeadersDelete Delete a header rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesHeadersDeleteRequest
*/
func (a *RulesAPIService) RulesHeadersDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesHeadersDeleteRequest {
	return RulesAPIRulesHeadersDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
func (a *RulesAPIService) RulesHeadersDeleteExecute(r RulesAPIRulesHeadersDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesHeadersDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/headers/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RulesAPIRulesHeadersListRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
}

func (r RulesAPIRulesHeadersListRequest) Execute() ([]V2RuleHeader, *http.Response, error) {
	return r.ApiService.RulesHeadersListExecute(r)
}

/*
RulesHeadersList List header rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesHeadersListRequest
*/
func (a *RulesAPIService) RulesHeadersList(ctx context.Context, organization string, project string) RulesAPIRulesHeadersListRequest {
	return RulesAPIRulesHeadersListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2RuleHeader
func (a *RulesAPIService) RulesHeadersListExecute(r RulesAPIRulesHeadersListRequest) ([]V2RuleHeader, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2RuleHeader
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesHeadersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/headers"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesHeadersReadRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesHeadersReadRequest) Execute() (*V2RuleHeader, *http.Response, error) {
	return r.ApiService.RulesHeadersReadExecute(r)
}

/*
RulesHeadersRead Get details of a header rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesHeadersReadRequest
*/
func (a *RulesAPIService) RulesHeadersRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesHeadersReadRequest {
	return RulesAPIRulesHeadersReadRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleHeader
func (a *RulesAPIService) RulesHeadersReadExecute(r RulesAPIRulesHeadersReadRequest) (*V2RuleHeader, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleHeader
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesHeadersRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/headers/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesHeadersUpdateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
	v2RuleHeaderRequest *V2RuleHeaderRequest
}

func (r RulesAPIRulesHeadersUpdateRequest) V2RuleHeaderRequest(v2RuleHeaderRequest V2RuleHeaderRequest) RulesAPIRulesHeadersUpdateRequest {
	r.v2RuleHeaderRequest = &v2RuleHeaderRequest
	return r
}

func (r RulesAPIRulesHeadersUpdateRequest) Execute() (*V2RuleHeader, *http.Response, error) {
	return r.ApiService.RulesHeadersUpdateExecute(r)
}

/*
RulesHeadersUpdate Update a header rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesHeadersUpdateRequest
*/
func (a *RulesAPIService) RulesHeadersUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesHeadersUpdateRequest {
	return RulesAPIRulesHeadersUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleHeader
func (a *RulesAPIService) RulesHeadersUpdateExecute(r RulesAPIRulesHeadersUpdateRequest) (*V2RuleHeader, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleHeader
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesHeadersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/headers/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleHeaderRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleHeaderRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleHeaderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesProxyCreateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	v2RuleProxyRequest *V2RuleProxyRequest
}

func (r RulesAPIRulesProxyCreateRequest) V2RuleProxyRequest(v2RuleProxyRequest V2RuleProxyRequest) RulesAPIRulesProxyCreateRequest {
	r.v2RuleProxyRequest = &v2RuleProxyRequest
	return r
}

func (r RulesAPIRulesProxyCreateRequest) Execute() (*V2RuleProxy, *http.Response, error) {
	return r.ApiService.RulesProxyCreateExecute(r)
}

/*
RulesProxyCreate Create a proxy rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @return RulesAPIRulesProxyCreateRequest
*/
func (a *RulesAPIService) RulesProxyCreate(ctx context.Context, organization string, project string) RulesAPIRulesProxyCreateRequest {
	return RulesAPIRulesProxyCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2RuleProxy
func (a *RulesAPIService) RulesProxyCreateExecute(r RulesAPIRulesProxyCreateRequest) (*V2RuleProxy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleProxy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesProxyCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/proxy"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleProxyRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleProxyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleProxyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesProxyDeleteRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesProxyDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RulesProxyDeleteExecute(r)
}

/*
RulesProxyDelete Delete a proxy rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @param rule
 @return RulesAPIRulesProxyDeleteRequest
*/
func (a *RulesAPIService) RulesProxyDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesProxyDeleteRequest {
	return RulesAPIRulesProxyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
func (a *RulesAPIService) RulesProxyDeleteExecute(r RulesAPIRulesProxyDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesProxyDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/proxy/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RulesAPIRulesProxyListRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
}

func (r RulesAPIRulesProxyListRequest) Execute() ([]V2RuleProxy, *http.Response, error) {
	return r.ApiService.RulesProxyListExecute(r)
}

/*
RulesProxyList List proxy rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @return RulesAPIRulesProxyListRequest
*/
func (a *RulesAPIService) RulesProxyList(ctx context.Context, organization string, project string) RulesAPIRulesProxyListRequest {
	return RulesAPIRulesProxyListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2RuleProxy
func (a *RulesAPIService) RulesProxyListExecute(r RulesAPIRulesProxyListRequest) ([]V2RuleProxy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2RuleProxy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesProxyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/proxy"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesProxyReadRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesProxyReadRequest) Execute() (*V2RuleProxy, *http.Response, error) {
	return r.ApiService.RulesProxyReadExecute(r)
}

/*
RulesProxyRead Get details of a proxy rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @param rule
 @return RulesAPIRulesProxyReadRequest
*/
func (a *RulesAPIService) RulesProxyRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesProxyReadRequest {
	return RulesAPIRulesProxyReadRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleProxy
func (a *RulesAPIService) RulesProxyReadExecute(r RulesAPIRulesProxyReadRequest) (*V2RuleProxy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleProxy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesProxyRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/proxy/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesProxyUpdateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
	v2RuleProxyRequest *V2RuleProxyRequest
}

func (r RulesAPIRulesProxyUpdateRequest) V2RuleProxyRequest(v2RuleProxyRequest V2RuleProxyRequest) RulesAPIRulesProxyUpdateRequest {
	r.v2RuleProxyRequest = &v2RuleProxyRequest
	return r
}

func (r RulesAPIRulesProxyUpdateRequest) Execute() (*V2RuleProxy, *http.Response, error) {
	return r.ApiService.RulesProxyUpdateExecute(r)
}

/*
RulesProxyUpdate Update a proxy rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @param rule
 @return RulesAPIRulesProxyUpdateRequest
*/
func (a *RulesAPIService) RulesProxyUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesProxyUpdateRequest {
	return RulesAPIRulesProxyUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleProxy
func (a *RulesAPIService) RulesProxyUpdateExecute(r RulesAPIRulesProxyUpdateRequest) (*V2RuleProxy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleProxy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesProxyUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/proxy/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleProxyRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleProxyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleProxyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesRedirectCreateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	v2RuleRedirectRequest *V2RuleRedirectRequest
}

func (r RulesAPIRulesRedirectCreateRequest) V2RuleRedirectRequest(v2RuleRedirectRequest V2RuleRedirectRequest) RulesAPIRulesRedirectCreateRequest {
	r.v2RuleRedirectRequest = &v2RuleRedirectRequest
	return r
}

func (r RulesAPIRulesRedirectCreateRequest) Execute() (*V2RuleRedirect, *http.Response, error) {
	return r.ApiService.RulesRedirectCreateExecute(r)
}

/*
RulesRedirectCreate Create a redirect rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @return RulesAPIRulesRedirectCreateRequest
*/
func (a *RulesAPIService) RulesRedirectCreate(ctx context.Context, organization string, project string) RulesAPIRulesRedirectCreateRequest {
	return RulesAPIRulesRedirectCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2RuleRedirect
func (a *RulesAPIService) RulesRedirectCreateExecute(r RulesAPIRulesRedirectCreateRequest) (*V2RuleRedirect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleRedirect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesRedirectCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleRedirectRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleRedirectRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleRedirectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesRedirectDeleteRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesRedirectDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RulesRedirectDeleteExecute(r)
}

/*
RulesRedirectDelete Delete a redirect rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @param rule
 @return RulesAPIRulesRedirectDeleteRequest
*/
func (a *RulesAPIService) RulesRedirectDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesRedirectDeleteRequest {
	return RulesAPIRulesRedirectDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
func (a *RulesAPIService) RulesRedirectDeleteExecute(r RulesAPIRulesRedirectDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesRedirectDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/redirect/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RulesAPIRulesRedirectListRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
}

func (r RulesAPIRulesRedirectListRequest) Execute() ([]V2RuleRedirect, *http.Response, error) {
	return r.ApiService.RulesRedirectListExecute(r)
}

/*
RulesRedirectList List redirect rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @return RulesAPIRulesRedirectListRequest
*/
func (a *RulesAPIService) RulesRedirectList(ctx context.Context, organization string, project string) RulesAPIRulesRedirectListRequest {
	return RulesAPIRulesRedirectListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2RuleRedirect
func (a *RulesAPIService) RulesRedirectListExecute(r RulesAPIRulesRedirectListRequest) ([]V2RuleRedirect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2RuleRedirect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesRedirectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesRedirectReadRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesRedirectReadRequest) Execute() (*V2RuleRedirect, *http.Response, error) {
	return r.ApiService.RulesRedirectReadExecute(r)
}

/*
RulesRedirectRead Get details of a redirect rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @param rule
 @return RulesAPIRulesRedirectReadRequest
*/
func (a *RulesAPIService) RulesRedirectRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesRedirectReadRequest {
	return RulesAPIRulesRedirectReadRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleRedirect
func (a *RulesAPIService) RulesRedirectReadExecute(r RulesAPIRulesRedirectReadRequest) (*V2RuleRedirect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleRedirect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesRedirectRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/redirect/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesRedirectUpdateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
	v2RuleRedirectRequest *V2RuleRedirectRequest
}

func (r RulesAPIRulesRedirectUpdateRequest) V2RuleRedirectRequest(v2RuleRedirectRequest V2RuleRedirectRequest) RulesAPIRulesRedirectUpdateRequest {
	r.v2RuleRedirectRequest = &v2RuleRedirectRequest
	return r
}

func (r RulesAPIRulesRedirectUpdateRequest) Execute() (*V2RuleRedirect, *http.Response, error) {
	return r.ApiService.RulesRedirectUpdateExecute(r)
}

/*
RulesRedirectUpdate Update a redirect rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization
 @param project
 @param rule
 @return RulesAPIRulesRedirectUpdateRequest
*/
func (a *RulesAPIService) RulesRedirectUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesRedirectUpdateRequest {
	return RulesAPIRulesRedirectUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleRedirect
func (a *RulesAPIService) RulesRedirectUpdateExecute(r RulesAPIRulesRedirectUpdateRequest) (*V2RuleRedirect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleRedirect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesRedirectUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/redirect/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleRedirectRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleRedirectRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleRedirectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesServeStaticCreateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	v2RuleServeStaticRequest *V2RuleServeStaticRequest
}

func (r RulesAPIRulesServeStaticCreateRequest) V2RuleServeStaticRequest(v2RuleServeStaticRequest V2RuleServeStaticRequest) RulesAPIRulesServeStaticCreateRequest {
	r.v2RuleServeStaticRequest = &v2RuleServeStaticRequest
	return r
}

func (r RulesAPIRulesServeStaticCreateRequest) Execute() (*V2RuleServeStatic, *http.Response, error) {
	return r.ApiService.RulesServeStaticCreateExecute(r)
}

/*
RulesServeStaticCreate Create a serve static rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesServeStaticCreateRequest
*/
func (a *RulesAPIService) RulesServeStaticCreate(ctx context.Context, organization string, project string) RulesAPIRulesServeStaticCreateRequest {
	return RulesAPIRulesServeStaticCreateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return V2RuleServeStatic
func (a *RulesAPIService) RulesServeStaticCreateExecute(r RulesAPIRulesServeStaticCreateRequest) (*V2RuleServeStatic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleServeStatic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesServeStaticCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/serve-static"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleServeStaticRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleServeStaticRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleServeStaticRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesServeStaticDeleteRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesServeStaticDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RulesServeStaticDeleteExecute(r)
}

/*
RulesServeStaticDelete Delete a serve static rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesServeStaticDeleteRequest
*/
func (a *RulesAPIService) RulesServeStaticDelete(ctx context.Context, organization string, project string, rule string) RulesAPIRulesServeStaticDeleteRequest {
	return RulesAPIRulesServeStaticDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
func (a *RulesAPIService) RulesServeStaticDeleteExecute(r RulesAPIRulesServeStaticDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesServeStaticDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/serve-static/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RulesAPIRulesServeStaticListRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
}

func (r RulesAPIRulesServeStaticListRequest) Execute() ([]V2RuleServeStatic, *http.Response, error) {
	return r.ApiService.RulesServeStaticListExecute(r)
}

/*
RulesServeStaticList List serve static rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @return RulesAPIRulesServeStaticListRequest
*/
func (a *RulesAPIService) RulesServeStaticList(ctx context.Context, organization string, project string) RulesAPIRulesServeStaticListRequest {
	return RulesAPIRulesServeStaticListRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return []V2RuleServeStatic
func (a *RulesAPIService) RulesServeStaticListExecute(r RulesAPIRulesServeStaticListRequest) ([]V2RuleServeStatic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V2RuleServeStatic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesServeStaticList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/serve-static"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesServeStaticReadRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
}

func (r RulesAPIRulesServeStaticReadRequest) Execute() (*V2RuleServeStatic, *http.Response, error) {
	return r.ApiService.RulesServeStaticReadExecute(r)
}

/*
RulesServeStaticRead Get details of a serve static rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesServeStaticReadRequest
*/
func (a *RulesAPIService) RulesServeStaticRead(ctx context.Context, organization string, project string, rule string) RulesAPIRulesServeStaticReadRequest {
	return RulesAPIRulesServeStaticReadRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleServeStatic
func (a *RulesAPIService) RulesServeStaticReadExecute(r RulesAPIRulesServeStaticReadRequest) (*V2RuleServeStatic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleServeStatic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesServeStaticRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/serve-static/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RulesAPIRulesServeStaticUpdateRequest struct {
	ctx context.Context
	ApiService RulesAPI
	organization string
	project string
	rule string
	v2RuleServeStaticRequest *V2RuleServeStaticRequest
}

func (r RulesAPIRulesServeStaticUpdateRequest) V2RuleServeStaticRequest(v2RuleServeStaticRequest V2RuleServeStaticRequest) RulesAPIRulesServeStaticUpdateRequest {
	r.v2RuleServeStaticRequest = &v2RuleServeStaticRequest
	return r
}

func (r RulesAPIRulesServeStaticUpdateRequest) Execute() (*V2RuleServeStatic, *http.Response, error) {
	return r.ApiService.RulesServeStaticUpdateExecute(r)
}

/*
RulesServeStaticUpdate Update a serve static rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization identifier
 @param project Project identifier
 @param rule Rule identifier
 @return RulesAPIRulesServeStaticUpdateRequest
*/
func (a *RulesAPIService) RulesServeStaticUpdate(ctx context.Context, organization string, project string, rule string) RulesAPIRulesServeStaticUpdateRequest {
	return RulesAPIRulesServeStaticUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return V2RuleServeStatic
func (a *RulesAPIService) RulesServeStaticUpdateExecute(r RulesAPIRulesServeStaticUpdateRequest) (*V2RuleServeStatic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RuleServeStatic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.RulesServeStaticUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/organizations/{organization}/projects/{project}/rules/serve-static/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2RuleServeStaticRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleServeStaticRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2RuleServeStaticRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

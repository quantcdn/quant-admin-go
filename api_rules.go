/*
Quant administration API

The Quant administration API provides programmatic access to manage projects within your available organizations. 

API version: 2.0.0
Contact: apiteam@quantcdn.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RulesAPIService RulesAPI service
type RulesAPIService service

type ApiOrganizationsOrganizationProjectsProjectRulesAuthPostRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	body *RuleAuthRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesAuthPostRequest) Body(body RuleAuthRequest) ApiOrganizationsOrganizationProjectsProjectRulesAuthPostRequest {
	r.body = &body
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesAuthPostRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesAuthPostExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesAuthPost Create authentication rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesAuthPostRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesAuthPost(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesAuthPostRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesAuthPostRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesAuthPostExecute(r ApiOrganizationsOrganizationProjectsProjectRulesAuthPostRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesAuthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/auth"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleDeleteRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleDeleteRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesAuthRuleDeleteExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesAuthRuleDelete Delete an authentication rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleDeleteRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesAuthRuleDelete(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleDeleteRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesAuthRuleDeleteExecute(r ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleDeleteRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesAuthRuleDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/auth/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleGetRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleGetRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesAuthRuleGetExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesAuthRuleGet Get authentication rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleGetRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesAuthRuleGet(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleGetRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleGetRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesAuthRuleGetExecute(r ApiOrganizationsOrganizationProjectsProjectRulesAuthRuleGetRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesAuthRuleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/auth/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesAuthRulePatchRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	body *RuleAuthRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesAuthRulePatchRequest) Body(body RuleAuthRequest) ApiOrganizationsOrganizationProjectsProjectRulesAuthRulePatchRequest {
	r.body = &body
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesAuthRulePatchRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesAuthRulePatchExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesAuthRulePatch Update authentication rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesAuthRulePatchRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesAuthRulePatch(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesAuthRulePatchRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesAuthRulePatchRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesAuthRulePatchExecute(r ApiOrganizationsOrganizationProjectsProjectRulesAuthRulePatchRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesAuthRulePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/auth/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesCustomResponsePatchRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	body *RuleCustomResponseRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponsePatchRequest) Body(body RuleCustomResponseRequest) ApiOrganizationsOrganizationProjectsProjectRulesCustomResponsePatchRequest {
	r.body = &body
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponsePatchRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesCustomResponsePatchExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesCustomResponsePatch Update custom response rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesCustomResponsePatchRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesCustomResponsePatch(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesCustomResponsePatchRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesCustomResponsePatchRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesCustomResponsePatchExecute(r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponsePatchRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesCustomResponsePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/custom-response"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDeleteRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDeleteRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDeleteExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDelete Delete a custom response rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDeleteRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDelete(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDeleteRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDeleteExecute(r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDeleteRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/custom-response/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGetRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGetRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGetExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGet Get custom repsonse rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGetRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGet(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGetRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGetRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGetExecute(r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGetRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesCustomResponseRuleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/custom-response/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	body *RuleCustomResponseRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchRequest) Body(body RuleCustomResponseRequest) ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchRequest {
	r.body = &body
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatch Update custom response rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatch(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchExecute(r ApiOrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatchRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesCustomResponseRulePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/custom-response/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesGetRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesGetRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesGet200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesGetExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesGet Get rules for a project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @return ApiOrganizationsOrganizationProjectsProjectRulesGetRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesGet(ctx context.Context, organization interface{}, project interface{}) ApiOrganizationsOrganizationProjectsProjectRulesGetRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesGetRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesGet200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesGetExecute(r ApiOrganizationsOrganizationProjectsProjectRulesGetRequest) (*OrganizationsOrganizationProjectsProjectRulesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesHeaderPatchRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	body *RuleHeaderRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesHeaderPatchRequest) Body(body RuleHeaderRequest) ApiOrganizationsOrganizationProjectsProjectRulesHeaderPatchRequest {
	r.body = &body
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesHeaderPatchRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesHeaderPatchExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesHeaderPatch Create header rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesHeaderPatchRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesHeaderPatch(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesHeaderPatchRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesHeaderPatchRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesHeaderPatchExecute(r ApiOrganizationsOrganizationProjectsProjectRulesHeaderPatchRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesHeaderPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/header"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleDeleteRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleDeleteRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesHeaderRuleDeleteExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesHeaderRuleDelete Delete a header rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleDeleteRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesHeaderRuleDelete(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleDeleteRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesHeaderRuleDeleteExecute(r ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleDeleteRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesHeaderRuleDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/header/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleGetRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleGetRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesHeaderRuleGetExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesHeaderRuleGet Get header rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleGetRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesHeaderRuleGet(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleGetRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleGetRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesHeaderRuleGetExecute(r ApiOrganizationsOrganizationProjectsProjectRulesHeaderRuleGetRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesHeaderRuleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/header/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesHeaderRulePatchRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	body *RuleHeaderRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesHeaderRulePatchRequest) Body(body RuleHeaderRequest) ApiOrganizationsOrganizationProjectsProjectRulesHeaderRulePatchRequest {
	r.body = &body
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesHeaderRulePatchRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesHeaderRulePatchExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesHeaderRulePatch Update header rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesHeaderRulePatchRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesHeaderRulePatch(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesHeaderRulePatchRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesHeaderRulePatchRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesHeaderRulePatchExecute(r ApiOrganizationsOrganizationProjectsProjectRulesHeaderRulePatchRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesHeaderRulePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/header/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesProxyPostRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	body *RuleProxyRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesProxyPostRequest) Body(body RuleProxyRequest) ApiOrganizationsOrganizationProjectsProjectRulesProxyPostRequest {
	r.body = &body
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesProxyPostRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesProxyPostExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesProxyPost Update proxy rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesProxyPostRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesProxyPost(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesProxyPostRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesProxyPostRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesProxyPostExecute(r ApiOrganizationsOrganizationProjectsProjectRulesProxyPostRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesProxyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/proxy"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleDeleteRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleDeleteRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesProxyRuleDeleteExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesProxyRuleDelete Delete a proxy rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleDeleteRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesProxyRuleDelete(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleDeleteRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesProxyRuleDeleteExecute(r ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleDeleteRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesProxyRuleDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/proxy/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleGetRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleGetRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesProxyRuleGetExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesProxyRuleGet Get proxy rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleGetRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesProxyRuleGet(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleGetRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleGetRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesProxyRuleGetExecute(r ApiOrganizationsOrganizationProjectsProjectRulesProxyRuleGetRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesProxyRuleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/proxy/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesProxyRulePatchRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	body *RuleProxyRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesProxyRulePatchRequest) Body(body RuleProxyRequest) ApiOrganizationsOrganizationProjectsProjectRulesProxyRulePatchRequest {
	r.body = &body
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesProxyRulePatchRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesProxyRulePatchExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesProxyRulePatch Update proxy rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesProxyRulePatchRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesProxyRulePatch(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesProxyRulePatchRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesProxyRulePatchRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesProxyRulePatchExecute(r ApiOrganizationsOrganizationProjectsProjectRulesProxyRulePatchRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesProxyRulePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/proxy/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesRedirectPostRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	ruleRedirectRequest *RuleRedirectRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesRedirectPostRequest) RuleRedirectRequest(ruleRedirectRequest RuleRedirectRequest) ApiOrganizationsOrganizationProjectsProjectRulesRedirectPostRequest {
	r.ruleRedirectRequest = &ruleRedirectRequest
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesRedirectPostRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesRedirectPostExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesRedirectPost Create a new redirect rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesRedirectPostRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesRedirectPost(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesRedirectPostRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesRedirectPostRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesRedirectPostExecute(r ApiOrganizationsOrganizationProjectsProjectRulesRedirectPostRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesRedirectPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ruleRedirectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleDeleteRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleDeleteRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesRedirectRuleDeleteExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesRedirectRuleDelete Delete a redirect rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleDeleteRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesRedirectRuleDelete(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleDeleteRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesRedirectRuleDeleteExecute(r ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleDeleteRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesRedirectRuleDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/redirect/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleGetRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleGetRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesRedirectRuleGetExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesRedirectRuleGet Get redirect rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleGetRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesRedirectRuleGet(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleGetRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleGetRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesRedirectRuleGetExecute(r ApiOrganizationsOrganizationProjectsProjectRulesRedirectRuleGetRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesRedirectRuleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/redirect/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationsOrganizationProjectsProjectRulesRedirectRulePatchRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	organization interface{}
	project interface{}
	rule interface{}
	ruleRedirectRequest *RuleRedirectRequest
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesRedirectRulePatchRequest) RuleRedirectRequest(ruleRedirectRequest RuleRedirectRequest) ApiOrganizationsOrganizationProjectsProjectRulesRedirectRulePatchRequest {
	r.ruleRedirectRequest = &ruleRedirectRequest
	return r
}

func (r ApiOrganizationsOrganizationProjectsProjectRulesRedirectRulePatchRequest) Execute() (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	return r.ApiService.OrganizationsOrganizationProjectsProjectRulesRedirectRulePatchExecute(r)
}

/*
OrganizationsOrganizationProjectsProjectRulesRedirectRulePatch Update redirect rule details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Organization machine name
 @param project Project machine name
 @param rule
 @return ApiOrganizationsOrganizationProjectsProjectRulesRedirectRulePatchRequest
*/
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesRedirectRulePatch(ctx context.Context, organization interface{}, project interface{}, rule interface{}) ApiOrganizationsOrganizationProjectsProjectRulesRedirectRulePatchRequest {
	return ApiOrganizationsOrganizationProjectsProjectRulesRedirectRulePatchRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		project: project,
		rule: rule,
	}
}

// Execute executes the request
//  @return OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
func (a *RulesAPIService) OrganizationsOrganizationProjectsProjectRulesRedirectRulePatchExecute(r ApiOrganizationsOrganizationProjectsProjectRulesRedirectRulePatchRequest) (*OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationsOrganizationProjectsProjectRulesRedirectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.OrganizationsOrganizationProjectsProjectRulesRedirectRulePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/rules/redirect/{rule}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rule"+"}", url.PathEscape(parameterValueToString(r.rule, "rule")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ruleRedirectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

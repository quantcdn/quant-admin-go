/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.10.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AIOrchestrationsAPI interface {

	/*
	CancelOrchestration Cancel Durable Orchestration

	Cancel an orchestration permanently. Cannot be resumed. Any in-progress items will complete, but no new processing starts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation machine name
	@param orchestrationId Orchestration identifier
	@return AIOrchestrationsAPICancelOrchestrationRequest
	*/
	CancelOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPICancelOrchestrationRequest

	// CancelOrchestrationExecute executes the request
	//  @return map[string]interface{}
	CancelOrchestrationExecute(r AIOrchestrationsAPICancelOrchestrationRequest) (map[string]interface{}, *http.Response, error)

	/*
	CreateOrchestration Create Durable Orchestration

	Create a new durable orchestration for batch processing.
     *
     * **Input Sources:**
     * - `static`: Process a fixed list of items
     * - `task_query`: Process tasks matching a query
     * - `generator`: AI generates items from a prompt
     *
     * **Stop Conditions:**
     * - `all_complete`: Stop when all items processed
     * - `max_iterations`: Stop after N iterations
     * - `condition`: AI evaluates a prompt to decide
     * - `manual`: Run until manually stopped
     *
     * **Auto-start:**
     * By default, the orchestration starts immediately. Set `autoStart: false` to create in pending state.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation machine name
	@return AIOrchestrationsAPICreateOrchestrationRequest
	*/
	CreateOrchestration(ctx context.Context, organisation string) AIOrchestrationsAPICreateOrchestrationRequest

	// CreateOrchestrationExecute executes the request
	//  @return map[string]interface{}
	CreateOrchestrationExecute(r AIOrchestrationsAPICreateOrchestrationRequest) (map[string]interface{}, *http.Response, error)

	/*
	DeleteOrchestration Delete Durable Orchestration

	Delete an orchestration. Can only delete orchestrations in completed, failed, or cancelled status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation machine name
	@param orchestrationId Orchestration identifier
	@return AIOrchestrationsAPIDeleteOrchestrationRequest
	*/
	DeleteOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIDeleteOrchestrationRequest

	// DeleteOrchestrationExecute executes the request
	DeleteOrchestrationExecute(r AIOrchestrationsAPIDeleteOrchestrationRequest) (*http.Response, error)

	/*
	GetOrchestration Get Durable Orchestration

	Get orchestration details including status and progress.
     *
     * **Progress Tracking:**
     * - `total`: Total items to process
     * - `completed`: Successfully processed
     * - `failed`: Failed processing
     * - `pending`: Awaiting processing

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation machine name
	@param orchestrationId Orchestration identifier
	@return AIOrchestrationsAPIGetOrchestrationRequest
	*/
	GetOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIGetOrchestrationRequest

	// GetOrchestrationExecute executes the request
	//  @return map[string]interface{}
	GetOrchestrationExecute(r AIOrchestrationsAPIGetOrchestrationRequest) (map[string]interface{}, *http.Response, error)

	/*
	ListOrchestrationBatches List Orchestration Batches

	Get history of batches processed by this orchestration. Returns paginated batch records with status and item counts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation machine name
	@param orchestrationId Orchestration identifier
	@return AIOrchestrationsAPIListOrchestrationBatchesRequest
	*/
	ListOrchestrationBatches(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIListOrchestrationBatchesRequest

	// ListOrchestrationBatchesExecute executes the request
	//  @return ListOrchestrationBatches200Response
	ListOrchestrationBatchesExecute(r AIOrchestrationsAPIListOrchestrationBatchesRequest) (*ListOrchestrationBatches200Response, *http.Response, error)

	/*
	ListOrchestrations List Durable Orchestrations

	List durable orchestrations for an organization with optional filtering.
     *
     * **Note:** This is different from `/tools/orchestrations` which handles async tool execution
     * polling. These durable orchestrations are for long-running batch processing loops.
     *
     * **Filter Options:**
     * - `status`: Filter by orchestration status
     * - `limit`: Max results (default 20, max 100)
     * - `cursor`: Pagination cursor

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation machine name
	@return AIOrchestrationsAPIListOrchestrationsRequest
	*/
	ListOrchestrations(ctx context.Context, organisation string) AIOrchestrationsAPIListOrchestrationsRequest

	// ListOrchestrationsExecute executes the request
	//  @return ListOrchestrations200Response
	ListOrchestrationsExecute(r AIOrchestrationsAPIListOrchestrationsRequest) (*ListOrchestrations200Response, *http.Response, error)

	/*
	PauseOrchestration Pause Durable Orchestration

	Pause a running orchestration. The current batch will complete, but no new batches will start. Can be resumed later.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation machine name
	@param orchestrationId Orchestration identifier
	@return AIOrchestrationsAPIPauseOrchestrationRequest
	*/
	PauseOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIPauseOrchestrationRequest

	// PauseOrchestrationExecute executes the request
	//  @return map[string]interface{}
	PauseOrchestrationExecute(r AIOrchestrationsAPIPauseOrchestrationRequest) (map[string]interface{}, *http.Response, error)

	/*
	ResumeOrchestration Resume Durable Orchestration

	Resume a paused orchestration. Processing continues from where it left off.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation machine name
	@param orchestrationId Orchestration identifier
	@return AIOrchestrationsAPIResumeOrchestrationRequest
	*/
	ResumeOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIResumeOrchestrationRequest

	// ResumeOrchestrationExecute executes the request
	//  @return map[string]interface{}
	ResumeOrchestrationExecute(r AIOrchestrationsAPIResumeOrchestrationRequest) (map[string]interface{}, *http.Response, error)

	/*
	StartOrchestration Start Durable Orchestration

	Start a pending orchestration. Only works on orchestrations created with `autoStart: false`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation machine name
	@param orchestrationId Orchestration identifier
	@return AIOrchestrationsAPIStartOrchestrationRequest
	*/
	StartOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIStartOrchestrationRequest

	// StartOrchestrationExecute executes the request
	//  @return map[string]interface{}
	StartOrchestrationExecute(r AIOrchestrationsAPIStartOrchestrationRequest) (map[string]interface{}, *http.Response, error)
}

// AIOrchestrationsAPIService AIOrchestrationsAPI service
type AIOrchestrationsAPIService service

type AIOrchestrationsAPICancelOrchestrationRequest struct {
	ctx context.Context
	ApiService AIOrchestrationsAPI
	organisation string
	orchestrationId string
}

func (r AIOrchestrationsAPICancelOrchestrationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CancelOrchestrationExecute(r)
}

/*
CancelOrchestration Cancel Durable Orchestration

Cancel an orchestration permanently. Cannot be resumed. Any in-progress items will complete, but no new processing starts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation machine name
 @param orchestrationId Orchestration identifier
 @return AIOrchestrationsAPICancelOrchestrationRequest
*/
func (a *AIOrchestrationsAPIService) CancelOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPICancelOrchestrationRequest {
	return AIOrchestrationsAPICancelOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		orchestrationId: orchestrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AIOrchestrationsAPIService) CancelOrchestrationExecute(r AIOrchestrationsAPICancelOrchestrationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIOrchestrationsAPIService.CancelOrchestration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/orchestrations/{orchestrationId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationId"+"}", url.PathEscape(parameterValueToString(r.orchestrationId, "orchestrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIOrchestrationsAPICreateOrchestrationRequest struct {
	ctx context.Context
	ApiService AIOrchestrationsAPI
	organisation string
	createOrchestrationRequest *CreateOrchestrationRequest
}

func (r AIOrchestrationsAPICreateOrchestrationRequest) CreateOrchestrationRequest(createOrchestrationRequest CreateOrchestrationRequest) AIOrchestrationsAPICreateOrchestrationRequest {
	r.createOrchestrationRequest = &createOrchestrationRequest
	return r
}

func (r AIOrchestrationsAPICreateOrchestrationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateOrchestrationExecute(r)
}

/*
CreateOrchestration Create Durable Orchestration

Create a new durable orchestration for batch processing.
     *
     * **Input Sources:**
     * - `static`: Process a fixed list of items
     * - `task_query`: Process tasks matching a query
     * - `generator`: AI generates items from a prompt
     *
     * **Stop Conditions:**
     * - `all_complete`: Stop when all items processed
     * - `max_iterations`: Stop after N iterations
     * - `condition`: AI evaluates a prompt to decide
     * - `manual`: Run until manually stopped
     *
     * **Auto-start:**
     * By default, the orchestration starts immediately. Set `autoStart: false` to create in pending state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation machine name
 @return AIOrchestrationsAPICreateOrchestrationRequest
*/
func (a *AIOrchestrationsAPIService) CreateOrchestration(ctx context.Context, organisation string) AIOrchestrationsAPICreateOrchestrationRequest {
	return AIOrchestrationsAPICreateOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AIOrchestrationsAPIService) CreateOrchestrationExecute(r AIOrchestrationsAPICreateOrchestrationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIOrchestrationsAPIService.CreateOrchestration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/orchestrations"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrchestrationRequest == nil {
		return localVarReturnValue, nil, reportError("createOrchestrationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrchestrationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIOrchestrationsAPIDeleteOrchestrationRequest struct {
	ctx context.Context
	ApiService AIOrchestrationsAPI
	organisation string
	orchestrationId string
}

func (r AIOrchestrationsAPIDeleteOrchestrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOrchestrationExecute(r)
}

/*
DeleteOrchestration Delete Durable Orchestration

Delete an orchestration. Can only delete orchestrations in completed, failed, or cancelled status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation machine name
 @param orchestrationId Orchestration identifier
 @return AIOrchestrationsAPIDeleteOrchestrationRequest
*/
func (a *AIOrchestrationsAPIService) DeleteOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIDeleteOrchestrationRequest {
	return AIOrchestrationsAPIDeleteOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		orchestrationId: orchestrationId,
	}
}

// Execute executes the request
func (a *AIOrchestrationsAPIService) DeleteOrchestrationExecute(r AIOrchestrationsAPIDeleteOrchestrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIOrchestrationsAPIService.DeleteOrchestration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/orchestrations/{orchestrationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationId"+"}", url.PathEscape(parameterValueToString(r.orchestrationId, "orchestrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AIOrchestrationsAPIGetOrchestrationRequest struct {
	ctx context.Context
	ApiService AIOrchestrationsAPI
	organisation string
	orchestrationId string
}

func (r AIOrchestrationsAPIGetOrchestrationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetOrchestrationExecute(r)
}

/*
GetOrchestration Get Durable Orchestration

Get orchestration details including status and progress.
     *
     * **Progress Tracking:**
     * - `total`: Total items to process
     * - `completed`: Successfully processed
     * - `failed`: Failed processing
     * - `pending`: Awaiting processing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation machine name
 @param orchestrationId Orchestration identifier
 @return AIOrchestrationsAPIGetOrchestrationRequest
*/
func (a *AIOrchestrationsAPIService) GetOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIGetOrchestrationRequest {
	return AIOrchestrationsAPIGetOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		orchestrationId: orchestrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AIOrchestrationsAPIService) GetOrchestrationExecute(r AIOrchestrationsAPIGetOrchestrationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIOrchestrationsAPIService.GetOrchestration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/orchestrations/{orchestrationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationId"+"}", url.PathEscape(parameterValueToString(r.orchestrationId, "orchestrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIOrchestrationsAPIListOrchestrationBatchesRequest struct {
	ctx context.Context
	ApiService AIOrchestrationsAPI
	organisation string
	orchestrationId string
	limit *int32
	cursor *string
}

// Maximum number of batches to return
func (r AIOrchestrationsAPIListOrchestrationBatchesRequest) Limit(limit int32) AIOrchestrationsAPIListOrchestrationBatchesRequest {
	r.limit = &limit
	return r
}

// Pagination cursor from previous response
func (r AIOrchestrationsAPIListOrchestrationBatchesRequest) Cursor(cursor string) AIOrchestrationsAPIListOrchestrationBatchesRequest {
	r.cursor = &cursor
	return r
}

func (r AIOrchestrationsAPIListOrchestrationBatchesRequest) Execute() (*ListOrchestrationBatches200Response, *http.Response, error) {
	return r.ApiService.ListOrchestrationBatchesExecute(r)
}

/*
ListOrchestrationBatches List Orchestration Batches

Get history of batches processed by this orchestration. Returns paginated batch records with status and item counts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation machine name
 @param orchestrationId Orchestration identifier
 @return AIOrchestrationsAPIListOrchestrationBatchesRequest
*/
func (a *AIOrchestrationsAPIService) ListOrchestrationBatches(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIListOrchestrationBatchesRequest {
	return AIOrchestrationsAPIListOrchestrationBatchesRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		orchestrationId: orchestrationId,
	}
}

// Execute executes the request
//  @return ListOrchestrationBatches200Response
func (a *AIOrchestrationsAPIService) ListOrchestrationBatchesExecute(r AIOrchestrationsAPIListOrchestrationBatchesRequest) (*ListOrchestrationBatches200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOrchestrationBatches200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIOrchestrationsAPIService.ListOrchestrationBatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/orchestrations/{orchestrationId}/batches"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationId"+"}", url.PathEscape(parameterValueToString(r.orchestrationId, "orchestrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIOrchestrationsAPIListOrchestrationsRequest struct {
	ctx context.Context
	ApiService AIOrchestrationsAPI
	organisation string
	status *string
	limit *int32
	cursor *string
}

// Filter by orchestration status
func (r AIOrchestrationsAPIListOrchestrationsRequest) Status(status string) AIOrchestrationsAPIListOrchestrationsRequest {
	r.status = &status
	return r
}

// Maximum number of results
func (r AIOrchestrationsAPIListOrchestrationsRequest) Limit(limit int32) AIOrchestrationsAPIListOrchestrationsRequest {
	r.limit = &limit
	return r
}

// Pagination cursor from previous response
func (r AIOrchestrationsAPIListOrchestrationsRequest) Cursor(cursor string) AIOrchestrationsAPIListOrchestrationsRequest {
	r.cursor = &cursor
	return r
}

func (r AIOrchestrationsAPIListOrchestrationsRequest) Execute() (*ListOrchestrations200Response, *http.Response, error) {
	return r.ApiService.ListOrchestrationsExecute(r)
}

/*
ListOrchestrations List Durable Orchestrations

List durable orchestrations for an organization with optional filtering.
     *
     * **Note:** This is different from `/tools/orchestrations` which handles async tool execution
     * polling. These durable orchestrations are for long-running batch processing loops.
     *
     * **Filter Options:**
     * - `status`: Filter by orchestration status
     * - `limit`: Max results (default 20, max 100)
     * - `cursor`: Pagination cursor

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation machine name
 @return AIOrchestrationsAPIListOrchestrationsRequest
*/
func (a *AIOrchestrationsAPIService) ListOrchestrations(ctx context.Context, organisation string) AIOrchestrationsAPIListOrchestrationsRequest {
	return AIOrchestrationsAPIListOrchestrationsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListOrchestrations200Response
func (a *AIOrchestrationsAPIService) ListOrchestrationsExecute(r AIOrchestrationsAPIListOrchestrationsRequest) (*ListOrchestrations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOrchestrations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIOrchestrationsAPIService.ListOrchestrations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/orchestrations"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIOrchestrationsAPIPauseOrchestrationRequest struct {
	ctx context.Context
	ApiService AIOrchestrationsAPI
	organisation string
	orchestrationId string
}

func (r AIOrchestrationsAPIPauseOrchestrationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PauseOrchestrationExecute(r)
}

/*
PauseOrchestration Pause Durable Orchestration

Pause a running orchestration. The current batch will complete, but no new batches will start. Can be resumed later.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation machine name
 @param orchestrationId Orchestration identifier
 @return AIOrchestrationsAPIPauseOrchestrationRequest
*/
func (a *AIOrchestrationsAPIService) PauseOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIPauseOrchestrationRequest {
	return AIOrchestrationsAPIPauseOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		orchestrationId: orchestrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AIOrchestrationsAPIService) PauseOrchestrationExecute(r AIOrchestrationsAPIPauseOrchestrationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIOrchestrationsAPIService.PauseOrchestration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/orchestrations/{orchestrationId}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationId"+"}", url.PathEscape(parameterValueToString(r.orchestrationId, "orchestrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIOrchestrationsAPIResumeOrchestrationRequest struct {
	ctx context.Context
	ApiService AIOrchestrationsAPI
	organisation string
	orchestrationId string
}

func (r AIOrchestrationsAPIResumeOrchestrationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ResumeOrchestrationExecute(r)
}

/*
ResumeOrchestration Resume Durable Orchestration

Resume a paused orchestration. Processing continues from where it left off.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation machine name
 @param orchestrationId Orchestration identifier
 @return AIOrchestrationsAPIResumeOrchestrationRequest
*/
func (a *AIOrchestrationsAPIService) ResumeOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIResumeOrchestrationRequest {
	return AIOrchestrationsAPIResumeOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		orchestrationId: orchestrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AIOrchestrationsAPIService) ResumeOrchestrationExecute(r AIOrchestrationsAPIResumeOrchestrationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIOrchestrationsAPIService.ResumeOrchestration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/orchestrations/{orchestrationId}/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationId"+"}", url.PathEscape(parameterValueToString(r.orchestrationId, "orchestrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIOrchestrationsAPIStartOrchestrationRequest struct {
	ctx context.Context
	ApiService AIOrchestrationsAPI
	organisation string
	orchestrationId string
}

func (r AIOrchestrationsAPIStartOrchestrationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.StartOrchestrationExecute(r)
}

/*
StartOrchestration Start Durable Orchestration

Start a pending orchestration. Only works on orchestrations created with `autoStart: false`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation machine name
 @param orchestrationId Orchestration identifier
 @return AIOrchestrationsAPIStartOrchestrationRequest
*/
func (a *AIOrchestrationsAPIService) StartOrchestration(ctx context.Context, organisation string, orchestrationId string) AIOrchestrationsAPIStartOrchestrationRequest {
	return AIOrchestrationsAPIStartOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		orchestrationId: orchestrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AIOrchestrationsAPIService) StartOrchestrationExecute(r AIOrchestrationsAPIStartOrchestrationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIOrchestrationsAPIService.StartOrchestration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/orchestrations/{orchestrationId}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationId"+"}", url.PathEscape(parameterValueToString(r.orchestrationId, "orchestrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.9.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AISessionsAPI interface {

	/*
	CreateAISession Create a new chat session with multi-tenant isolation

	Creates an AI session with automatic expiration (60 min default, 24h max). Sessions are isolated by organization. Use userId to identify the user creating the session. Use sessionGroup for logical grouping. Use metadata for additional custom data. Filter sessions by userId or sessionGroup when listing.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AISessionsAPICreateAISessionRequest
	*/
	CreateAISession(ctx context.Context, organisation string) AISessionsAPICreateAISessionRequest

	// CreateAISessionExecute executes the request
	//  @return CreateAISession201Response
	CreateAISessionExecute(r AISessionsAPICreateAISessionRequest) (*CreateAISession201Response, *http.Response, error)

	/*
	DeleteAISession Delete a chat session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param sessionId The session ID
	@return AISessionsAPIDeleteAISessionRequest
	*/
	DeleteAISession(ctx context.Context, organisation string, sessionId string) AISessionsAPIDeleteAISessionRequest

	// DeleteAISessionExecute executes the request
	//  @return DeleteAISession200Response
	DeleteAISessionExecute(r AISessionsAPIDeleteAISessionRequest) (*DeleteAISession200Response, *http.Response, error)

	/*
	ExtendAISession Extend Session Expiration

	Extends the expiration time of an active session. Useful for keeping long-running conversations alive.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param sessionId The session ID
	@return AISessionsAPIExtendAISessionRequest
	*/
	ExtendAISession(ctx context.Context, organisation string, sessionId string) AISessionsAPIExtendAISessionRequest

	// ExtendAISessionExecute executes the request
	//  @return ExtendAISession200Response
	ExtendAISessionExecute(r AISessionsAPIExtendAISessionRequest) (*ExtendAISession200Response, *http.Response, error)

	/*
	GetAISession Get a specific chat session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param sessionId The session ID
	@return AISessionsAPIGetAISessionRequest
	*/
	GetAISession(ctx context.Context, organisation string, sessionId string) AISessionsAPIGetAISessionRequest

	// GetAISessionExecute executes the request
	//  @return GetAISession200Response
	GetAISessionExecute(r AISessionsAPIGetAISessionRequest) (*GetAISession200Response, *http.Response, error)

	/*
	ListAISessions List chat sessions with multi-tenant filtering

	Lists active sessions for an organization with flexible filtering options.
     *
     * **Query Combinations:**
     * 1. By Organization (default): Returns all sessions in the organization
     * 2. By Organization + Group: `?sessionGroup=drupal-prod` - Sessions in a specific group
     * 3. By User: `?userId=user-123` - All sessions for a user
     * 4. By User + Group: `?userId=user-123&sessionGroup=drupal-prod` - User's sessions in a specific group
     *
     * **Use Cases:**
     * - List user's conversations in a specific app/environment
     * - Admin view of all sessions in a customer/tenant group
     * - User profile showing all AI conversations across apps

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AISessionsAPIListAISessionsRequest
	*/
	ListAISessions(ctx context.Context, organisation string) AISessionsAPIListAISessionsRequest

	// ListAISessionsExecute executes the request
	//  @return []ListAISessions200ResponseInner
	ListAISessionsExecute(r AISessionsAPIListAISessionsRequest) ([]ListAISessions200ResponseInner, *http.Response, error)

	/*
	UpdateAISession Update Session

	Updates session with new conversation messages and tracks token usage. Appends new messages to conversation history and updates session stats.
     *
     * **Typical Flow:**
     * 1. Get session to retrieve conversation history
     * 2. Call AI inference with full message history
     * 3. Update session with new user + assistant messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param sessionId The session ID
	@return AISessionsAPIUpdateAISessionRequest
	*/
	UpdateAISession(ctx context.Context, organisation string, sessionId string) AISessionsAPIUpdateAISessionRequest

	// UpdateAISessionExecute executes the request
	//  @return UpdateAISession200Response
	UpdateAISessionExecute(r AISessionsAPIUpdateAISessionRequest) (*UpdateAISession200Response, *http.Response, error)
}

// AISessionsAPIService AISessionsAPI service
type AISessionsAPIService service

type AISessionsAPICreateAISessionRequest struct {
	ctx context.Context
	ApiService AISessionsAPI
	organisation string
	createAISessionRequest *CreateAISessionRequest
}

func (r AISessionsAPICreateAISessionRequest) CreateAISessionRequest(createAISessionRequest CreateAISessionRequest) AISessionsAPICreateAISessionRequest {
	r.createAISessionRequest = &createAISessionRequest
	return r
}

func (r AISessionsAPICreateAISessionRequest) Execute() (*CreateAISession201Response, *http.Response, error) {
	return r.ApiService.CreateAISessionExecute(r)
}

/*
CreateAISession Create a new chat session with multi-tenant isolation

Creates an AI session with automatic expiration (60 min default, 24h max). Sessions are isolated by organization. Use userId to identify the user creating the session. Use sessionGroup for logical grouping. Use metadata for additional custom data. Filter sessions by userId or sessionGroup when listing.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AISessionsAPICreateAISessionRequest
*/
func (a *AISessionsAPIService) CreateAISession(ctx context.Context, organisation string) AISessionsAPICreateAISessionRequest {
	return AISessionsAPICreateAISessionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return CreateAISession201Response
func (a *AISessionsAPIService) CreateAISessionExecute(r AISessionsAPICreateAISessionRequest) (*CreateAISession201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAISession201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AISessionsAPIService.CreateAISession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAISessionRequest == nil {
		return localVarReturnValue, nil, reportError("createAISessionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAISessionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AISessionsAPIDeleteAISessionRequest struct {
	ctx context.Context
	ApiService AISessionsAPI
	organisation string
	sessionId string
}

func (r AISessionsAPIDeleteAISessionRequest) Execute() (*DeleteAISession200Response, *http.Response, error) {
	return r.ApiService.DeleteAISessionExecute(r)
}

/*
DeleteAISession Delete a chat session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param sessionId The session ID
 @return AISessionsAPIDeleteAISessionRequest
*/
func (a *AISessionsAPIService) DeleteAISession(ctx context.Context, organisation string, sessionId string) AISessionsAPIDeleteAISessionRequest {
	return AISessionsAPIDeleteAISessionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return DeleteAISession200Response
func (a *AISessionsAPIService) DeleteAISessionExecute(r AISessionsAPIDeleteAISessionRequest) (*DeleteAISession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAISession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AISessionsAPIService.DeleteAISession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AISessionsAPIExtendAISessionRequest struct {
	ctx context.Context
	ApiService AISessionsAPI
	organisation string
	sessionId string
	extendAISessionRequest *ExtendAISessionRequest
}

func (r AISessionsAPIExtendAISessionRequest) ExtendAISessionRequest(extendAISessionRequest ExtendAISessionRequest) AISessionsAPIExtendAISessionRequest {
	r.extendAISessionRequest = &extendAISessionRequest
	return r
}

func (r AISessionsAPIExtendAISessionRequest) Execute() (*ExtendAISession200Response, *http.Response, error) {
	return r.ApiService.ExtendAISessionExecute(r)
}

/*
ExtendAISession Extend Session Expiration

Extends the expiration time of an active session. Useful for keeping long-running conversations alive.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param sessionId The session ID
 @return AISessionsAPIExtendAISessionRequest
*/
func (a *AISessionsAPIService) ExtendAISession(ctx context.Context, organisation string, sessionId string) AISessionsAPIExtendAISessionRequest {
	return AISessionsAPIExtendAISessionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return ExtendAISession200Response
func (a *AISessionsAPIService) ExtendAISessionExecute(r AISessionsAPIExtendAISessionRequest) (*ExtendAISession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtendAISession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AISessionsAPIService.ExtendAISession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions/{sessionId}/extend"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.extendAISessionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AISessionsAPIGetAISessionRequest struct {
	ctx context.Context
	ApiService AISessionsAPI
	organisation string
	sessionId string
}

func (r AISessionsAPIGetAISessionRequest) Execute() (*GetAISession200Response, *http.Response, error) {
	return r.ApiService.GetAISessionExecute(r)
}

/*
GetAISession Get a specific chat session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param sessionId The session ID
 @return AISessionsAPIGetAISessionRequest
*/
func (a *AISessionsAPIService) GetAISession(ctx context.Context, organisation string, sessionId string) AISessionsAPIGetAISessionRequest {
	return AISessionsAPIGetAISessionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return GetAISession200Response
func (a *AISessionsAPIService) GetAISessionExecute(r AISessionsAPIGetAISessionRequest) (*GetAISession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAISession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AISessionsAPIService.GetAISession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AISessionsAPIListAISessionsRequest struct {
	ctx context.Context
	ApiService AISessionsAPI
	organisation string
	userId *string
	sessionGroup *string
	limit *int32
	offset *int32
	model *string
}

// Filter sessions by user ID
func (r AISessionsAPIListAISessionsRequest) UserId(userId string) AISessionsAPIListAISessionsRequest {
	r.userId = &userId
	return r
}

// Filter by session group. Returns only sessions matching the specified group.
func (r AISessionsAPIListAISessionsRequest) SessionGroup(sessionGroup string) AISessionsAPIListAISessionsRequest {
	r.sessionGroup = &sessionGroup
	return r
}

// Maximum number of sessions to return (default 50, max 100)
func (r AISessionsAPIListAISessionsRequest) Limit(limit int32) AISessionsAPIListAISessionsRequest {
	r.limit = &limit
	return r
}

// Offset for pagination
func (r AISessionsAPIListAISessionsRequest) Offset(offset int32) AISessionsAPIListAISessionsRequest {
	r.offset = &offset
	return r
}

// Filter by model ID
func (r AISessionsAPIListAISessionsRequest) Model(model string) AISessionsAPIListAISessionsRequest {
	r.model = &model
	return r
}

func (r AISessionsAPIListAISessionsRequest) Execute() ([]ListAISessions200ResponseInner, *http.Response, error) {
	return r.ApiService.ListAISessionsExecute(r)
}

/*
ListAISessions List chat sessions with multi-tenant filtering

Lists active sessions for an organization with flexible filtering options.
     *
     * **Query Combinations:**
     * 1. By Organization (default): Returns all sessions in the organization
     * 2. By Organization + Group: `?sessionGroup=drupal-prod` - Sessions in a specific group
     * 3. By User: `?userId=user-123` - All sessions for a user
     * 4. By User + Group: `?userId=user-123&sessionGroup=drupal-prod` - User's sessions in a specific group
     *
     * **Use Cases:**
     * - List user's conversations in a specific app/environment
     * - Admin view of all sessions in a customer/tenant group
     * - User profile showing all AI conversations across apps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AISessionsAPIListAISessionsRequest
*/
func (a *AISessionsAPIService) ListAISessions(ctx context.Context, organisation string) AISessionsAPIListAISessionsRequest {
	return AISessionsAPIListAISessionsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return []ListAISessions200ResponseInner
func (a *AISessionsAPIService) ListAISessionsExecute(r AISessionsAPIListAISessionsRequest) ([]ListAISessions200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListAISessions200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AISessionsAPIService.ListAISessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.sessionGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionGroup", r.sessionGroup, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AISessionsAPIUpdateAISessionRequest struct {
	ctx context.Context
	ApiService AISessionsAPI
	organisation string
	sessionId string
	updateAISessionRequest *UpdateAISessionRequest
}

func (r AISessionsAPIUpdateAISessionRequest) UpdateAISessionRequest(updateAISessionRequest UpdateAISessionRequest) AISessionsAPIUpdateAISessionRequest {
	r.updateAISessionRequest = &updateAISessionRequest
	return r
}

func (r AISessionsAPIUpdateAISessionRequest) Execute() (*UpdateAISession200Response, *http.Response, error) {
	return r.ApiService.UpdateAISessionExecute(r)
}

/*
UpdateAISession Update Session

Updates session with new conversation messages and tracks token usage. Appends new messages to conversation history and updates session stats.
     *
     * **Typical Flow:**
     * 1. Get session to retrieve conversation history
     * 2. Call AI inference with full message history
     * 3. Update session with new user + assistant messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param sessionId The session ID
 @return AISessionsAPIUpdateAISessionRequest
*/
func (a *AISessionsAPIService) UpdateAISession(ctx context.Context, organisation string, sessionId string) AISessionsAPIUpdateAISessionRequest {
	return AISessionsAPIUpdateAISessionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return UpdateAISession200Response
func (a *AISessionsAPIService) UpdateAISessionExecute(r AISessionsAPIUpdateAISessionRequest) (*UpdateAISession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAISession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AISessionsAPIService.UpdateAISession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAISessionRequest == nil {
		return localVarReturnValue, nil, reportError("updateAISessionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAISessionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

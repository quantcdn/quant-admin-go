/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


type BackupManagementAPI interface {

	/*
	CreateBackup Create a backup for an environment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param application The application ID
	@param environment The environment ID
	@param type_ The backup type
	@return BackupManagementAPICreateBackupRequest
	*/
	CreateBackup(ctx context.Context, organisation string, application string, environment string, type_ string) BackupManagementAPICreateBackupRequest

	// CreateBackupExecute executes the request
	//  @return CreateBackup202Response
	CreateBackupExecute(r BackupManagementAPICreateBackupRequest) (*CreateBackup202Response, *http.Response, error)

	/*
	DeleteBackup Delete a backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param application The application ID
	@param environment The environment ID
	@param type_ The backup type
	@param backupId The backup ID
	@return BackupManagementAPIDeleteBackupRequest
	*/
	DeleteBackup(ctx context.Context, organisation string, application string, environment string, type_ string, backupId string) BackupManagementAPIDeleteBackupRequest

	// DeleteBackupExecute executes the request
	//  @return DeleteBackup200Response
	DeleteBackupExecute(r BackupManagementAPIDeleteBackupRequest) (*DeleteBackup200Response, *http.Response, error)

	/*
	DownloadBackup Generate a download URL for a backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param application The application ID
	@param environment The environment ID
	@param type_ The backup type
	@param backupId The backup ID
	@return BackupManagementAPIDownloadBackupRequest
	*/
	DownloadBackup(ctx context.Context, organisation string, application string, environment string, type_ string, backupId string) BackupManagementAPIDownloadBackupRequest

	// DownloadBackupExecute executes the request
	//  @return DownloadBackup200Response
	DownloadBackupExecute(r BackupManagementAPIDownloadBackupRequest) (*DownloadBackup200Response, *http.Response, error)

	/*
	ListBackups List backups for an environment

	Retrieves a list of backups (database or filesystem) for the environment with status, size, and metadata. Supports filtering and ordering via query parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param application The application ID
	@param environment The environment ID
	@param type_ The backup type
	@return BackupManagementAPIListBackupsRequest
	*/
	ListBackups(ctx context.Context, organisation string, application string, environment string, type_ string) BackupManagementAPIListBackupsRequest

	// ListBackupsExecute executes the request
	//  @return ListBackups200Response
	ListBackupsExecute(r BackupManagementAPIListBackupsRequest) (*ListBackups200Response, *http.Response, error)
}

// BackupManagementAPIService BackupManagementAPI service
type BackupManagementAPIService service

type BackupManagementAPICreateBackupRequest struct {
	ctx context.Context
	ApiService BackupManagementAPI
	organisation string
	application string
	environment string
	type_ string
	createBackupRequest *CreateBackupRequest
}

func (r BackupManagementAPICreateBackupRequest) CreateBackupRequest(createBackupRequest CreateBackupRequest) BackupManagementAPICreateBackupRequest {
	r.createBackupRequest = &createBackupRequest
	return r
}

func (r BackupManagementAPICreateBackupRequest) Execute() (*CreateBackup202Response, *http.Response, error) {
	return r.ApiService.CreateBackupExecute(r)
}

/*
CreateBackup Create a backup for an environment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param application The application ID
 @param environment The environment ID
 @param type_ The backup type
 @return BackupManagementAPICreateBackupRequest
*/
func (a *BackupManagementAPIService) CreateBackup(ctx context.Context, organisation string, application string, environment string, type_ string) BackupManagementAPICreateBackupRequest {
	return BackupManagementAPICreateBackupRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		application: application,
		environment: environment,
		type_: type_,
	}
}

// Execute executes the request
//  @return CreateBackup202Response
func (a *BackupManagementAPIService) CreateBackupExecute(r BackupManagementAPICreateBackupRequest) (*CreateBackup202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBackup202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupManagementAPIService.CreateBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/backups/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", url.PathEscape(parameterValueToString(r.application, "application")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment"+"}", url.PathEscape(parameterValueToString(r.environment, "environment")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBackupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupManagementAPIDeleteBackupRequest struct {
	ctx context.Context
	ApiService BackupManagementAPI
	organisation string
	application string
	environment string
	type_ string
	backupId string
}

func (r BackupManagementAPIDeleteBackupRequest) Execute() (*DeleteBackup200Response, *http.Response, error) {
	return r.ApiService.DeleteBackupExecute(r)
}

/*
DeleteBackup Delete a backup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param application The application ID
 @param environment The environment ID
 @param type_ The backup type
 @param backupId The backup ID
 @return BackupManagementAPIDeleteBackupRequest
*/
func (a *BackupManagementAPIService) DeleteBackup(ctx context.Context, organisation string, application string, environment string, type_ string, backupId string) BackupManagementAPIDeleteBackupRequest {
	return BackupManagementAPIDeleteBackupRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		application: application,
		environment: environment,
		type_: type_,
		backupId: backupId,
	}
}

// Execute executes the request
//  @return DeleteBackup200Response
func (a *BackupManagementAPIService) DeleteBackupExecute(r BackupManagementAPIDeleteBackupRequest) (*DeleteBackup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteBackup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupManagementAPIService.DeleteBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/backups/{type}/{backupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", url.PathEscape(parameterValueToString(r.application, "application")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment"+"}", url.PathEscape(parameterValueToString(r.environment, "environment")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupManagementAPIDownloadBackupRequest struct {
	ctx context.Context
	ApiService BackupManagementAPI
	organisation string
	application string
	environment string
	type_ string
	backupId string
}

func (r BackupManagementAPIDownloadBackupRequest) Execute() (*DownloadBackup200Response, *http.Response, error) {
	return r.ApiService.DownloadBackupExecute(r)
}

/*
DownloadBackup Generate a download URL for a backup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param application The application ID
 @param environment The environment ID
 @param type_ The backup type
 @param backupId The backup ID
 @return BackupManagementAPIDownloadBackupRequest
*/
func (a *BackupManagementAPIService) DownloadBackup(ctx context.Context, organisation string, application string, environment string, type_ string, backupId string) BackupManagementAPIDownloadBackupRequest {
	return BackupManagementAPIDownloadBackupRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		application: application,
		environment: environment,
		type_: type_,
		backupId: backupId,
	}
}

// Execute executes the request
//  @return DownloadBackup200Response
func (a *BackupManagementAPIService) DownloadBackupExecute(r BackupManagementAPIDownloadBackupRequest) (*DownloadBackup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DownloadBackup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupManagementAPIService.DownloadBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/backups/{type}/{backupId}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", url.PathEscape(parameterValueToString(r.application, "application")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment"+"}", url.PathEscape(parameterValueToString(r.environment, "environment")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupManagementAPIListBackupsRequest struct {
	ctx context.Context
	ApiService BackupManagementAPI
	organisation string
	application string
	environment string
	type_ string
	order *string
	limit *int32
	createdBefore *time.Time
	createdAfter *time.Time
	status *string
	nextToken *string
}

// Sort order for backups by creation date (asc &#x3D; oldest first, desc &#x3D; newest first)
func (r BackupManagementAPIListBackupsRequest) Order(order string) BackupManagementAPIListBackupsRequest {
	r.order = &order
	return r
}

// Maximum number of backups to return (max 100)
func (r BackupManagementAPIListBackupsRequest) Limit(limit int32) BackupManagementAPIListBackupsRequest {
	r.limit = &limit
	return r
}

// Only return backups created before this ISO 8601 timestamp (e.g., 2025-01-01T00:00:00Z)
func (r BackupManagementAPIListBackupsRequest) CreatedBefore(createdBefore time.Time) BackupManagementAPIListBackupsRequest {
	r.createdBefore = &createdBefore
	return r
}

// Only return backups created after this ISO 8601 timestamp (e.g., 2024-12-01T00:00:00Z)
func (r BackupManagementAPIListBackupsRequest) CreatedAfter(createdAfter time.Time) BackupManagementAPIListBackupsRequest {
	r.createdAfter = &createdAfter
	return r
}

// Filter backups by status
func (r BackupManagementAPIListBackupsRequest) Status(status string) BackupManagementAPIListBackupsRequest {
	r.status = &status
	return r
}

// Token for retrieving the next page of results
func (r BackupManagementAPIListBackupsRequest) NextToken(nextToken string) BackupManagementAPIListBackupsRequest {
	r.nextToken = &nextToken
	return r
}

func (r BackupManagementAPIListBackupsRequest) Execute() (*ListBackups200Response, *http.Response, error) {
	return r.ApiService.ListBackupsExecute(r)
}

/*
ListBackups List backups for an environment

Retrieves a list of backups (database or filesystem) for the environment with status, size, and metadata. Supports filtering and ordering via query parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param application The application ID
 @param environment The environment ID
 @param type_ The backup type
 @return BackupManagementAPIListBackupsRequest
*/
func (a *BackupManagementAPIService) ListBackups(ctx context.Context, organisation string, application string, environment string, type_ string) BackupManagementAPIListBackupsRequest {
	return BackupManagementAPIListBackupsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		application: application,
		environment: environment,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListBackups200Response
func (a *BackupManagementAPIService) ListBackupsExecute(r BackupManagementAPIListBackupsRequest) (*ListBackups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListBackups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BackupManagementAPIService.ListBackups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/backups/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", url.PathEscape(parameterValueToString(r.application, "application")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment"+"}", url.PathEscape(parameterValueToString(r.environment, "environment")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "form", "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfter", r.createdAfter, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nextToken", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ListBackups422Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

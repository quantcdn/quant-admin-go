/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.8.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AIToolsAPI interface {

	/*
	GetAIToolExecutionStatus Get async tool execution status and result

	Retrieves the status and result of an async tool execution. Used for polling long-running tools like image generation.
     *
     * **Async Tool Execution Pattern:**
     * This endpoint enables a polling pattern for long-running tools that would otherwise hit API Gateway's 30-second timeout.
     *
     * **Flow:**
     * 1. AI requests tool use (e.g., `generate_image`)
     * 2. Chat API returns `toolUse` with execution tracking info
     * 3. Client starts polling this endpoint with the `executionId`
     * 4. When `status === 'complete'`, retrieve `result` and send back to AI
     * 5. AI incorporates result into final response
     *
     * **Status Values:**
     * - `pending`: Tool execution queued, not yet started
     * - `running`: Tool is currently executing
     * - `complete`: Tool execution finished successfully, `result` available
     * - `failed`: Tool execution failed, `error` available
     *
     * **Polling Recommendations:**
     * - Poll every 2-3 seconds for image generation
     * - Exponential backoff for other tools (start 1s, max 5s)
     * - Stop polling after 5 minutes (consider failed)
     * - Auto-cleanup after 24 hours (TTL)
     *
     * **Use Cases:**
     * - Image generation (10-15s typical runtime)
     * - Video processing
     * - Large file uploads/downloads
     * - Complex database queries
     * - External API calls with high latency

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param executionId Tool execution identifier
	@return AIToolsAPIGetAIToolExecutionStatusRequest
	*/
	GetAIToolExecutionStatus(ctx context.Context, organisation string, executionId string) AIToolsAPIGetAIToolExecutionStatusRequest

	// GetAIToolExecutionStatusExecute executes the request
	//  @return GetAIToolExecutionStatus200Response
	GetAIToolExecutionStatusExecute(r AIToolsAPIGetAIToolExecutionStatusRequest) (*GetAIToolExecutionStatus200Response, *http.Response, error)

	/*
	ListAIToolExecutions List tool executions for monitoring and debugging

	Lists recent async tool executions for an organization. Useful for debugging, monitoring, and building admin UIs.
     *
     * **Query Patterns:**
     * - All recent executions: `GET /ai/tools/executions`
     * - Filter by status: `GET /ai/tools/executions?status=running`
     * - Limit results: `GET /ai/tools/executions?limit=20`
     *
     * **Results:**
     * - Ordered by creation time (newest first)
     * - Limited to 50 by default (configurable via `limit` parameter)
     * - Only shows executions not yet expired (24h TTL)
     *
     * **Use Cases:**
     * - Monitor all active tool executions
     * - Debug failed executions
     * - Build admin dashboards
     * - Track tool usage patterns
     * - Audit async operations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIToolsAPIListAIToolExecutionsRequest
	*/
	ListAIToolExecutions(ctx context.Context, organisation string) AIToolsAPIListAIToolExecutionsRequest

	// ListAIToolExecutionsExecute executes the request
	//  @return ListAIToolExecutions200Response
	ListAIToolExecutionsExecute(r AIToolsAPIListAIToolExecutionsRequest) (*ListAIToolExecutions200Response, *http.Response, error)

	/*
	ListAIToolNames List tool names only (lightweight response)

	Retrieves just the names of available built-in tools. Useful for quick validation or UI dropdown population without the full tool specifications.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIToolsAPIListAIToolNamesRequest
	*/
	ListAIToolNames(ctx context.Context, organisation string) AIToolsAPIListAIToolNamesRequest

	// ListAIToolNamesExecute executes the request
	//  @return ListAIToolNames200Response
	ListAIToolNamesExecute(r AIToolsAPIListAIToolNamesRequest) (*ListAIToolNames200Response, *http.Response, error)

	/*
	ListAITools List available built-in tools for function calling

	Retrieves all available built-in tools that can be used with function calling. These tools can be included in `toolConfig` when making AI inference requests.
     *
     * **Available Built-in Tools:**
     * - `get_weather`: Get current weather for a location using Open-Meteo API
     * - `calculate`: Perform basic mathematical calculations (add, subtract, multiply, divide)
     * - `search_web`: Search the web for information (mock implementation)
     * - `generate_image`: Generate images with Amazon Nova Canvas (async execution, 10-15s typical runtime)
     *
     * **Use Cases:**
     * - Discover available tools dynamically without hardcoding
     * - Get complete tool specifications including input schemas
     * - Build UI for tool selection
     * - Validate tool names before sending requests
     *
     * **Dynamic Tool Discovery:**
     * This endpoint enables clients to:
     * 1. Fetch all available tools on page load
     * 2. Display tool capabilities to users
     * 3. Filter tools based on user permissions
     * 4. Use `allowedTools` whitelist for security
     *
     * **Alternative Endpoint:**
     * - `GET /ai/tools/names` - Returns only tool names (faster, lighter response)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIToolsAPIListAIToolsRequest
	*/
	ListAITools(ctx context.Context, organisation string) AIToolsAPIListAIToolsRequest

	// ListAIToolsExecute executes the request
	//  @return ListAITools200Response
	ListAIToolsExecute(r AIToolsAPIListAIToolsRequest) (*ListAITools200Response, *http.Response, error)
}

// AIToolsAPIService AIToolsAPI service
type AIToolsAPIService service

type AIToolsAPIGetAIToolExecutionStatusRequest struct {
	ctx context.Context
	ApiService AIToolsAPI
	organisation string
	executionId string
}

func (r AIToolsAPIGetAIToolExecutionStatusRequest) Execute() (*GetAIToolExecutionStatus200Response, *http.Response, error) {
	return r.ApiService.GetAIToolExecutionStatusExecute(r)
}

/*
GetAIToolExecutionStatus Get async tool execution status and result

Retrieves the status and result of an async tool execution. Used for polling long-running tools like image generation.
     *
     * **Async Tool Execution Pattern:**
     * This endpoint enables a polling pattern for long-running tools that would otherwise hit API Gateway's 30-second timeout.
     *
     * **Flow:**
     * 1. AI requests tool use (e.g., `generate_image`)
     * 2. Chat API returns `toolUse` with execution tracking info
     * 3. Client starts polling this endpoint with the `executionId`
     * 4. When `status === 'complete'`, retrieve `result` and send back to AI
     * 5. AI incorporates result into final response
     *
     * **Status Values:**
     * - `pending`: Tool execution queued, not yet started
     * - `running`: Tool is currently executing
     * - `complete`: Tool execution finished successfully, `result` available
     * - `failed`: Tool execution failed, `error` available
     *
     * **Polling Recommendations:**
     * - Poll every 2-3 seconds for image generation
     * - Exponential backoff for other tools (start 1s, max 5s)
     * - Stop polling after 5 minutes (consider failed)
     * - Auto-cleanup after 24 hours (TTL)
     *
     * **Use Cases:**
     * - Image generation (10-15s typical runtime)
     * - Video processing
     * - Large file uploads/downloads
     * - Complex database queries
     * - External API calls with high latency

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param executionId Tool execution identifier
 @return AIToolsAPIGetAIToolExecutionStatusRequest
*/
func (a *AIToolsAPIService) GetAIToolExecutionStatus(ctx context.Context, organisation string, executionId string) AIToolsAPIGetAIToolExecutionStatusRequest {
	return AIToolsAPIGetAIToolExecutionStatusRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		executionId: executionId,
	}
}

// Execute executes the request
//  @return GetAIToolExecutionStatus200Response
func (a *AIToolsAPIService) GetAIToolExecutionStatusExecute(r AIToolsAPIGetAIToolExecutionStatusRequest) (*GetAIToolExecutionStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAIToolExecutionStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIToolsAPIService.GetAIToolExecutionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tools/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAIToolExecutionStatus404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIToolsAPIListAIToolExecutionsRequest struct {
	ctx context.Context
	ApiService AIToolsAPI
	organisation string
	status *string
	limit *int32
}

// Filter by execution status
func (r AIToolsAPIListAIToolExecutionsRequest) Status(status string) AIToolsAPIListAIToolExecutionsRequest {
	r.status = &status
	return r
}

// Maximum number of executions to return
func (r AIToolsAPIListAIToolExecutionsRequest) Limit(limit int32) AIToolsAPIListAIToolExecutionsRequest {
	r.limit = &limit
	return r
}

func (r AIToolsAPIListAIToolExecutionsRequest) Execute() (*ListAIToolExecutions200Response, *http.Response, error) {
	return r.ApiService.ListAIToolExecutionsExecute(r)
}

/*
ListAIToolExecutions List tool executions for monitoring and debugging

Lists recent async tool executions for an organization. Useful for debugging, monitoring, and building admin UIs.
     *
     * **Query Patterns:**
     * - All recent executions: `GET /ai/tools/executions`
     * - Filter by status: `GET /ai/tools/executions?status=running`
     * - Limit results: `GET /ai/tools/executions?limit=20`
     *
     * **Results:**
     * - Ordered by creation time (newest first)
     * - Limited to 50 by default (configurable via `limit` parameter)
     * - Only shows executions not yet expired (24h TTL)
     *
     * **Use Cases:**
     * - Monitor all active tool executions
     * - Debug failed executions
     * - Build admin dashboards
     * - Track tool usage patterns
     * - Audit async operations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIToolsAPIListAIToolExecutionsRequest
*/
func (a *AIToolsAPIService) ListAIToolExecutions(ctx context.Context, organisation string) AIToolsAPIListAIToolExecutionsRequest {
	return AIToolsAPIListAIToolExecutionsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListAIToolExecutions200Response
func (a *AIToolsAPIService) ListAIToolExecutionsExecute(r AIToolsAPIListAIToolExecutionsRequest) (*ListAIToolExecutions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAIToolExecutions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIToolsAPIService.ListAIToolExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tools/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIToolsAPIListAIToolNamesRequest struct {
	ctx context.Context
	ApiService AIToolsAPI
	organisation string
}

func (r AIToolsAPIListAIToolNamesRequest) Execute() (*ListAIToolNames200Response, *http.Response, error) {
	return r.ApiService.ListAIToolNamesExecute(r)
}

/*
ListAIToolNames List tool names only (lightweight response)

Retrieves just the names of available built-in tools. Useful for quick validation or UI dropdown population without the full tool specifications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIToolsAPIListAIToolNamesRequest
*/
func (a *AIToolsAPIService) ListAIToolNames(ctx context.Context, organisation string) AIToolsAPIListAIToolNamesRequest {
	return AIToolsAPIListAIToolNamesRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListAIToolNames200Response
func (a *AIToolsAPIService) ListAIToolNamesExecute(r AIToolsAPIListAIToolNamesRequest) (*ListAIToolNames200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAIToolNames200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIToolsAPIService.ListAIToolNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tools/names"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIToolsAPIListAIToolsRequest struct {
	ctx context.Context
	ApiService AIToolsAPI
	organisation string
}

func (r AIToolsAPIListAIToolsRequest) Execute() (*ListAITools200Response, *http.Response, error) {
	return r.ApiService.ListAIToolsExecute(r)
}

/*
ListAITools List available built-in tools for function calling

Retrieves all available built-in tools that can be used with function calling. These tools can be included in `toolConfig` when making AI inference requests.
     *
     * **Available Built-in Tools:**
     * - `get_weather`: Get current weather for a location using Open-Meteo API
     * - `calculate`: Perform basic mathematical calculations (add, subtract, multiply, divide)
     * - `search_web`: Search the web for information (mock implementation)
     * - `generate_image`: Generate images with Amazon Nova Canvas (async execution, 10-15s typical runtime)
     *
     * **Use Cases:**
     * - Discover available tools dynamically without hardcoding
     * - Get complete tool specifications including input schemas
     * - Build UI for tool selection
     * - Validate tool names before sending requests
     *
     * **Dynamic Tool Discovery:**
     * This endpoint enables clients to:
     * 1. Fetch all available tools on page load
     * 2. Display tool capabilities to users
     * 3. Filter tools based on user permissions
     * 4. Use `allowedTools` whitelist for security
     *
     * **Alternative Endpoint:**
     * - `GET /ai/tools/names` - Returns only tool names (faster, lighter response)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIToolsAPIListAIToolsRequest
*/
func (a *AIToolsAPIService) ListAITools(ctx context.Context, organisation string) AIToolsAPIListAIToolsRequest {
	return AIToolsAPIListAIToolsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListAITools200Response
func (a *AIToolsAPIService) ListAIToolsExecute(r AIToolsAPIListAIToolsRequest) (*ListAITools200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAITools200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIToolsAPIService.ListAITools")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tools"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AIServicesAPI interface {

	/*
	ChatInference Chat inference via API Gateway (buffered responses) with multimodal support

	Sends requests to the AI API Gateway endpoint which buffers responses. Supports text, images, videos, and documents via base64 encoding.
     *
     * **Multimodal Support:**
     * - **Text**: Simple string content
     * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)
     * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)
     * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)
     *
     * **Supported Models:**
     * - Amazon Nova Lite, Micro, Pro (all support multimodal)
     * - Claude models (text only)
     *
     * **Usage Tips:**
     * - Use base64 encoding for images/videos < 5-10MB
     * - Place media before text prompts for best results
     * - Label multiple media files (e.g., 'Image 1:', 'Image 2:')
     * - Maximum 25MB total payload size
     *
     * **Response Patterns:**
     * - **Text-only**: Returns simple text response when no tools requested
     * - **Single tool**: Returns `toolUse` object when AI requests one tool
     * - **Multiple tools**: Returns `toolUse` array when AI requests multiple tools
     * - **Auto-execute sync**: Automatically executes tool and returns final text response
     * - **Auto-execute async**: Returns toolUse with `executionId` and `status` for polling

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIChatInferenceRequest
	*/
	ChatInference(ctx context.Context, organisation string) AIServicesAPIChatInferenceRequest

	// ChatInferenceExecute executes the request
	//  @return ChatInference200Response
	ChatInferenceExecute(r AIServicesAPIChatInferenceRequest) (*ChatInference200Response, *http.Response, error)

	/*
	ChatInferenceStream Chat inference via streaming endpoint (true HTTP streaming) with multimodal support

	Streams responses from the AI streaming subdomain using Server-Sent Events (SSE). Tokens are streamed in real-time as they are generated.
     *
     * **Multimodal Support:**
     * - **Text**: Simple string content
     * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)
     * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)
     * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)
     *
     * **Supported Models:**
     * - Amazon Nova Lite, Micro, Pro (all support multimodal)
     * - Claude models (text only)
     *
     * **Usage Tips:**
     * - Use base64 encoding for images/videos < 5-10MB
     * - Place media before text prompts for best results
     * - Label multiple media files (e.g., 'Image 1:', 'Image 2:')
     * - Maximum 25MB total payload size
     * - Streaming works with all content types (text, image, video, document)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIChatInferenceStreamRequest
	*/
	ChatInferenceStream(ctx context.Context, organisation string) AIServicesAPIChatInferenceStreamRequest

	// ChatInferenceStreamExecute executes the request
	//  @return string
	ChatInferenceStreamExecute(r AIServicesAPIChatInferenceStreamRequest) (string, *http.Response, error)

	/*
	CreateAISession Create a new chat session with multi-tenant isolation

	Creates an AI session with automatic expiration (60 min default, 24h max). Sessions are isolated by organization. Use userId to identify the user creating the session. Use sessionGroup for logical grouping. Use metadata for additional custom data. Filter sessions by userId or sessionGroup when listing.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPICreateAISessionRequest
	*/
	CreateAISession(ctx context.Context, organisation string) AIServicesAPICreateAISessionRequest

	// CreateAISessionExecute executes the request
	//  @return CreateAISession201Response
	CreateAISessionExecute(r AIServicesAPICreateAISessionRequest) (*CreateAISession201Response, *http.Response, error)

	/*
	DeleteAISession Delete a chat session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param sessionId The session ID
	@return AIServicesAPIDeleteAISessionRequest
	*/
	DeleteAISession(ctx context.Context, organisation string, sessionId string) AIServicesAPIDeleteAISessionRequest

	// DeleteAISessionExecute executes the request
	//  @return DeleteAISession200Response
	DeleteAISessionExecute(r AIServicesAPIDeleteAISessionRequest) (*DeleteAISession200Response, *http.Response, error)

	/*
	Embeddings Generate text embeddings for semantic search and RAG applications

	Generates vector embeddings for text content using embedding models. Used for semantic search, document similarity, and RAG applications.
     *
     * **Features:**
     * - Single text or batch processing (up to 100 texts)
     * - Configurable dimensions (256, 512, 1024, 8192 for Titan v2)
     * - Optional normalization to unit length
     * - Usage tracking for billing
     *
     * **Use Cases:**
     * - Semantic search across documents
     * - Similarity matching for content recommendations
     * - RAG (Retrieval-Augmented Generation) pipelines
     * - Clustering and classification
     *
     * **Available Embedding Models:**
     * - amazon.titan-embed-text-v2:0 (default, supports 256-8192 dimensions)
     * - amazon.titan-embed-text-v1:0 (1536 dimensions fixed)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIEmbeddingsRequest
	*/
	Embeddings(ctx context.Context, organisation string) AIServicesAPIEmbeddingsRequest

	// EmbeddingsExecute executes the request
	//  @return Embeddings200Response
	EmbeddingsExecute(r AIServicesAPIEmbeddingsRequest) (*Embeddings200Response, *http.Response, error)

	/*
	GetAIConfig Get AI configuration for an organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIGetAIConfigRequest
	*/
	GetAIConfig(ctx context.Context, organisation string) AIServicesAPIGetAIConfigRequest

	// GetAIConfigExecute executes the request
	//  @return GetAIConfig200Response
	GetAIConfigExecute(r AIServicesAPIGetAIConfigRequest) (*GetAIConfig200Response, *http.Response, error)

	/*
	GetAISession Get a specific chat session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param sessionId The session ID
	@return AIServicesAPIGetAISessionRequest
	*/
	GetAISession(ctx context.Context, organisation string, sessionId string) AIServicesAPIGetAISessionRequest

	// GetAISessionExecute executes the request
	//  @return GetAISession200Response
	GetAISessionExecute(r AIServicesAPIGetAISessionRequest) (*GetAISession200Response, *http.Response, error)

	/*
	GetAIUsageStats Get AI usage statistics

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIGetAIUsageStatsRequest
	*/
	GetAIUsageStats(ctx context.Context, organisation string) AIServicesAPIGetAIUsageStatsRequest

	// GetAIUsageStatsExecute executes the request
	//  @return GetAIUsageStats200Response
	GetAIUsageStatsExecute(r AIServicesAPIGetAIUsageStatsRequest) (*GetAIUsageStats200Response, *http.Response, error)

	/*
	GetToolExecutionStatus Get async tool execution status and result

	Retrieves the status and result of an async tool execution. Used for polling long-running tools like image generation.
     *
     * **Async Tool Execution Pattern:**
     * This endpoint enables a polling pattern for long-running tools that would otherwise hit API Gateway's 30-second timeout.
     *
     * **Flow:**
     * 1. AI requests tool use (e.g., `generate_image`)
     * 2. Chat API returns `toolUse` with execution tracking info
     * 3. Client starts polling this endpoint with the `executionId`
     * 4. When `status === 'complete'`, retrieve `result` and send back to AI
     * 5. AI incorporates result into final response
     *
     * **Status Values:**
     * - `pending`: Tool execution queued, not yet started
     * - `running`: Tool is currently executing
     * - `complete`: Tool execution finished successfully, `result` available
     * - `failed`: Tool execution failed, `error` available
     *
     * **Polling Recommendations:**
     * - Poll every 2-3 seconds for image generation
     * - Exponential backoff for other tools (start 1s, max 5s)
     * - Stop polling after 5 minutes (consider failed)
     * - Auto-cleanup after 24 hours (TTL)
     *
     * **Use Cases:**
     * - Image generation (10-15s typical runtime)
     * - Video processing
     * - Large file uploads/downloads
     * - Complex database queries
     * - External API calls with high latency

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param executionId Tool execution identifier
	@return AIServicesAPIGetToolExecutionStatusRequest
	*/
	GetToolExecutionStatus(ctx context.Context, organisation string, executionId string) AIServicesAPIGetToolExecutionStatusRequest

	// GetToolExecutionStatusExecute executes the request
	//  @return GetToolExecutionStatus200Response
	GetToolExecutionStatusExecute(r AIServicesAPIGetToolExecutionStatusRequest) (*GetToolExecutionStatus200Response, *http.Response, error)

	/*
	ImageGeneration Generate images with Amazon Nova Canvas

	Generates images using Amazon Nova Canvas image generation model.
     *
     * **Region Restriction:** Nova Canvas is ONLY available in:
     * - `us-east-1` (US East, N. Virginia)
     * - `ap-northeast-1` (Asia Pacific, Tokyo)
     * - `eu-west-1` (Europe, Ireland)
     * âŒ NOT available in `ap-southeast-2` (Sydney)
     *
     * **Supported Task Types:**
     * - **TEXT_IMAGE**: Basic text-to-image generation
     * - **TEXT_IMAGE with Conditioning**: Layout-guided generation using edge detection or segmentation
     * - **COLOR_GUIDED_GENERATION**: Generate images with specific color palettes
     * - **IMAGE_VARIATION**: Create variations of existing images
     * - **INPAINTING**: Fill masked areas in images
     * - **OUTPAINTING**: Extend images beyond their borders
     * - **BACKGROUND_REMOVAL**: Remove backgrounds from images
     * - **VIRTUAL_TRY_ON**: Try on garments/objects on people
     *
     * **Quality Options:**
     * - **standard**: Faster generation, lower cost
     * - **premium**: Higher quality, slower generation
     *
     * **Timeout:** Image generation can take up to 5 minutes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIImageGenerationRequest
	*/
	ImageGeneration(ctx context.Context, organisation string) AIServicesAPIImageGenerationRequest

	// ImageGenerationExecute executes the request
	//  @return ImageGeneration200Response
	ImageGenerationExecute(r AIServicesAPIImageGenerationRequest) (*ImageGeneration200Response, *http.Response, error)

	/*
	ListAIModels List available AI models for an organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIListAIModelsRequest
	*/
	ListAIModels(ctx context.Context, organisation string) AIServicesAPIListAIModelsRequest

	// ListAIModelsExecute executes the request
	//  @return ListAIModels200Response
	ListAIModelsExecute(r AIServicesAPIListAIModelsRequest) (*ListAIModels200Response, *http.Response, error)

	/*
	ListAISessions List chat sessions with multi-tenant filtering

	Lists active sessions for an organization with flexible filtering options.
     *
     * **Query Combinations:**
     * 1. By Organization (default): Returns all sessions in the organization
     * 2. By Organization + Group: `?sessionGroup=drupal-prod` - Sessions in a specific group
     * 3. By User: `?userId=user-123` - All sessions for a user
     * 4. By User + Group: `?userId=user-123&sessionGroup=drupal-prod` - User's sessions in a specific group
     *
     * **Use Cases:**
     * - List user's conversations in a specific app/environment
     * - Admin view of all sessions in a customer/tenant group
     * - User profile showing all AI conversations across apps

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIListAISessionsRequest
	*/
	ListAISessions(ctx context.Context, organisation string) AIServicesAPIListAISessionsRequest

	// ListAISessionsExecute executes the request
	//  @return []ListAISessions200ResponseInner
	ListAISessionsExecute(r AIServicesAPIListAISessionsRequest) ([]ListAISessions200ResponseInner, *http.Response, error)

	/*
	ListAIToolNames List tool names only (lightweight response)

	Retrieves just the names of available built-in tools. Useful for quick validation or UI dropdown population without the full tool specifications.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIListAIToolNamesRequest
	*/
	ListAIToolNames(ctx context.Context, organisation string) AIServicesAPIListAIToolNamesRequest

	// ListAIToolNamesExecute executes the request
	//  @return ListAIToolNames200Response
	ListAIToolNamesExecute(r AIServicesAPIListAIToolNamesRequest) (*ListAIToolNames200Response, *http.Response, error)

	/*
	ListAITools List available built-in tools for function calling

	Retrieves all available built-in tools that can be used with function calling. These tools can be included in `toolConfig` when making AI inference requests.
     *
     * **Available Built-in Tools:**
     * - `get_weather`: Get current weather for a location using Open-Meteo API
     * - `calculate`: Perform basic mathematical calculations (add, subtract, multiply, divide)
     * - `search_web`: Search the web for information (mock implementation)
     * - `generate_image`: Generate images with Amazon Nova Canvas (async execution, 10-15s typical runtime)
     *
     * **Use Cases:**
     * - Discover available tools dynamically without hardcoding
     * - Get complete tool specifications including input schemas
     * - Build UI for tool selection
     * - Validate tool names before sending requests
     *
     * **Dynamic Tool Discovery:**
     * This endpoint enables clients to:
     * 1. Fetch all available tools on page load
     * 2. Display tool capabilities to users
     * 3. Filter tools based on user permissions
     * 4. Use `allowedTools` whitelist for security
     *
     * **Alternative Endpoint:**
     * - `GET /ai/tools/names` - Returns only tool names (faster, lighter response)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIListAIToolsRequest
	*/
	ListAITools(ctx context.Context, organisation string) AIServicesAPIListAIToolsRequest

	// ListAIToolsExecute executes the request
	//  @return ListAITools200Response
	ListAIToolsExecute(r AIServicesAPIListAIToolsRequest) (*ListAITools200Response, *http.Response, error)

	/*
	ListToolExecutions List tool executions for monitoring and debugging

	Lists recent async tool executions for an organization. Useful for debugging, monitoring, and building admin UIs.
     *
     * **Query Patterns:**
     * - All recent executions: `GET /ai/tools/executions`
     * - Filter by status: `GET /ai/tools/executions?status=running`
     * - Limit results: `GET /ai/tools/executions?limit=20`
     *
     * **Results:**
     * - Ordered by creation time (newest first)
     * - Limited to 50 by default (configurable via `limit` parameter)
     * - Only shows executions not yet expired (24h TTL)
     *
     * **Use Cases:**
     * - Monitor all active tool executions
     * - Debug failed executions
     * - Build admin dashboards
     * - Track tool usage patterns
     * - Audit async operations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIListToolExecutionsRequest
	*/
	ListToolExecutions(ctx context.Context, organisation string) AIServicesAPIListToolExecutionsRequest

	// ListToolExecutionsExecute executes the request
	//  @return ListToolExecutions200Response
	ListToolExecutionsExecute(r AIServicesAPIListToolExecutionsRequest) (*ListToolExecutions200Response, *http.Response, error)

	/*
	UpdateAIConfig Update AI configuration for an organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return AIServicesAPIUpdateAIConfigRequest
	*/
	UpdateAIConfig(ctx context.Context, organisation string) AIServicesAPIUpdateAIConfigRequest

	// UpdateAIConfigExecute executes the request
	UpdateAIConfigExecute(r AIServicesAPIUpdateAIConfigRequest) (*http.Response, error)
}

// AIServicesAPIService AIServicesAPI service
type AIServicesAPIService service

type AIServicesAPIChatInferenceRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	chatInferenceRequest *ChatInferenceRequest
}

// Chat request with optional multimodal content blocks
func (r AIServicesAPIChatInferenceRequest) ChatInferenceRequest(chatInferenceRequest ChatInferenceRequest) AIServicesAPIChatInferenceRequest {
	r.chatInferenceRequest = &chatInferenceRequest
	return r
}

func (r AIServicesAPIChatInferenceRequest) Execute() (*ChatInference200Response, *http.Response, error) {
	return r.ApiService.ChatInferenceExecute(r)
}

/*
ChatInference Chat inference via API Gateway (buffered responses) with multimodal support

Sends requests to the AI API Gateway endpoint which buffers responses. Supports text, images, videos, and documents via base64 encoding.
     *
     * **Multimodal Support:**
     * - **Text**: Simple string content
     * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)
     * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)
     * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)
     *
     * **Supported Models:**
     * - Amazon Nova Lite, Micro, Pro (all support multimodal)
     * - Claude models (text only)
     *
     * **Usage Tips:**
     * - Use base64 encoding for images/videos < 5-10MB
     * - Place media before text prompts for best results
     * - Label multiple media files (e.g., 'Image 1:', 'Image 2:')
     * - Maximum 25MB total payload size
     *
     * **Response Patterns:**
     * - **Text-only**: Returns simple text response when no tools requested
     * - **Single tool**: Returns `toolUse` object when AI requests one tool
     * - **Multiple tools**: Returns `toolUse` array when AI requests multiple tools
     * - **Auto-execute sync**: Automatically executes tool and returns final text response
     * - **Auto-execute async**: Returns toolUse with `executionId` and `status` for polling

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIChatInferenceRequest
*/
func (a *AIServicesAPIService) ChatInference(ctx context.Context, organisation string) AIServicesAPIChatInferenceRequest {
	return AIServicesAPIChatInferenceRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ChatInference200Response
func (a *AIServicesAPIService) ChatInferenceExecute(r AIServicesAPIChatInferenceRequest) (*ChatInference200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatInference200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.ChatInference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/chat"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatInferenceRequest == nil {
		return localVarReturnValue, nil, reportError("chatInferenceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chatInferenceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIChatInferenceStreamRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	chatInferenceStreamRequest *ChatInferenceStreamRequest
}

// Chat request with optional multimodal content blocks
func (r AIServicesAPIChatInferenceStreamRequest) ChatInferenceStreamRequest(chatInferenceStreamRequest ChatInferenceStreamRequest) AIServicesAPIChatInferenceStreamRequest {
	r.chatInferenceStreamRequest = &chatInferenceStreamRequest
	return r
}

func (r AIServicesAPIChatInferenceStreamRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ChatInferenceStreamExecute(r)
}

/*
ChatInferenceStream Chat inference via streaming endpoint (true HTTP streaming) with multimodal support

Streams responses from the AI streaming subdomain using Server-Sent Events (SSE). Tokens are streamed in real-time as they are generated.
     *
     * **Multimodal Support:**
     * - **Text**: Simple string content
     * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)
     * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)
     * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)
     *
     * **Supported Models:**
     * - Amazon Nova Lite, Micro, Pro (all support multimodal)
     * - Claude models (text only)
     *
     * **Usage Tips:**
     * - Use base64 encoding for images/videos < 5-10MB
     * - Place media before text prompts for best results
     * - Label multiple media files (e.g., 'Image 1:', 'Image 2:')
     * - Maximum 25MB total payload size
     * - Streaming works with all content types (text, image, video, document)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIChatInferenceStreamRequest
*/
func (a *AIServicesAPIService) ChatInferenceStream(ctx context.Context, organisation string) AIServicesAPIChatInferenceStreamRequest {
	return AIServicesAPIChatInferenceStreamRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return string
func (a *AIServicesAPIService) ChatInferenceStreamExecute(r AIServicesAPIChatInferenceStreamRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.ChatInferenceStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/chat/stream"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatInferenceStreamRequest == nil {
		return localVarReturnValue, nil, reportError("chatInferenceStreamRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chatInferenceStreamRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPICreateAISessionRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	createAISessionRequest *CreateAISessionRequest
}

func (r AIServicesAPICreateAISessionRequest) CreateAISessionRequest(createAISessionRequest CreateAISessionRequest) AIServicesAPICreateAISessionRequest {
	r.createAISessionRequest = &createAISessionRequest
	return r
}

func (r AIServicesAPICreateAISessionRequest) Execute() (*CreateAISession201Response, *http.Response, error) {
	return r.ApiService.CreateAISessionExecute(r)
}

/*
CreateAISession Create a new chat session with multi-tenant isolation

Creates an AI session with automatic expiration (60 min default, 24h max). Sessions are isolated by organization. Use userId to identify the user creating the session. Use sessionGroup for logical grouping. Use metadata for additional custom data. Filter sessions by userId or sessionGroup when listing.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPICreateAISessionRequest
*/
func (a *AIServicesAPIService) CreateAISession(ctx context.Context, organisation string) AIServicesAPICreateAISessionRequest {
	return AIServicesAPICreateAISessionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return CreateAISession201Response
func (a *AIServicesAPIService) CreateAISessionExecute(r AIServicesAPICreateAISessionRequest) (*CreateAISession201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAISession201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.CreateAISession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAISessionRequest == nil {
		return localVarReturnValue, nil, reportError("createAISessionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAISessionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIDeleteAISessionRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	sessionId string
}

func (r AIServicesAPIDeleteAISessionRequest) Execute() (*DeleteAISession200Response, *http.Response, error) {
	return r.ApiService.DeleteAISessionExecute(r)
}

/*
DeleteAISession Delete a chat session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param sessionId The session ID
 @return AIServicesAPIDeleteAISessionRequest
*/
func (a *AIServicesAPIService) DeleteAISession(ctx context.Context, organisation string, sessionId string) AIServicesAPIDeleteAISessionRequest {
	return AIServicesAPIDeleteAISessionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return DeleteAISession200Response
func (a *AIServicesAPIService) DeleteAISessionExecute(r AIServicesAPIDeleteAISessionRequest) (*DeleteAISession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAISession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.DeleteAISession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIEmbeddingsRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	embeddingsRequest *EmbeddingsRequest
}

// Embedding request with single or multiple texts
func (r AIServicesAPIEmbeddingsRequest) EmbeddingsRequest(embeddingsRequest EmbeddingsRequest) AIServicesAPIEmbeddingsRequest {
	r.embeddingsRequest = &embeddingsRequest
	return r
}

func (r AIServicesAPIEmbeddingsRequest) Execute() (*Embeddings200Response, *http.Response, error) {
	return r.ApiService.EmbeddingsExecute(r)
}

/*
Embeddings Generate text embeddings for semantic search and RAG applications

Generates vector embeddings for text content using embedding models. Used for semantic search, document similarity, and RAG applications.
     *
     * **Features:**
     * - Single text or batch processing (up to 100 texts)
     * - Configurable dimensions (256, 512, 1024, 8192 for Titan v2)
     * - Optional normalization to unit length
     * - Usage tracking for billing
     *
     * **Use Cases:**
     * - Semantic search across documents
     * - Similarity matching for content recommendations
     * - RAG (Retrieval-Augmented Generation) pipelines
     * - Clustering and classification
     *
     * **Available Embedding Models:**
     * - amazon.titan-embed-text-v2:0 (default, supports 256-8192 dimensions)
     * - amazon.titan-embed-text-v1:0 (1536 dimensions fixed)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIEmbeddingsRequest
*/
func (a *AIServicesAPIService) Embeddings(ctx context.Context, organisation string) AIServicesAPIEmbeddingsRequest {
	return AIServicesAPIEmbeddingsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return Embeddings200Response
func (a *AIServicesAPIService) EmbeddingsExecute(r AIServicesAPIEmbeddingsRequest) (*Embeddings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Embeddings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.Embeddings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/embeddings"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.embeddingsRequest == nil {
		return localVarReturnValue, nil, reportError("embeddingsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.embeddingsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIGetAIConfigRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
}

func (r AIServicesAPIGetAIConfigRequest) Execute() (*GetAIConfig200Response, *http.Response, error) {
	return r.ApiService.GetAIConfigExecute(r)
}

/*
GetAIConfig Get AI configuration for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIGetAIConfigRequest
*/
func (a *AIServicesAPIService) GetAIConfig(ctx context.Context, organisation string) AIServicesAPIGetAIConfigRequest {
	return AIServicesAPIGetAIConfigRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return GetAIConfig200Response
func (a *AIServicesAPIService) GetAIConfigExecute(r AIServicesAPIGetAIConfigRequest) (*GetAIConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAIConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.GetAIConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/config"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIGetAISessionRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	sessionId string
}

func (r AIServicesAPIGetAISessionRequest) Execute() (*GetAISession200Response, *http.Response, error) {
	return r.ApiService.GetAISessionExecute(r)
}

/*
GetAISession Get a specific chat session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param sessionId The session ID
 @return AIServicesAPIGetAISessionRequest
*/
func (a *AIServicesAPIService) GetAISession(ctx context.Context, organisation string, sessionId string) AIServicesAPIGetAISessionRequest {
	return AIServicesAPIGetAISessionRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return GetAISession200Response
func (a *AIServicesAPIService) GetAISessionExecute(r AIServicesAPIGetAISessionRequest) (*GetAISession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAISession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.GetAISession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIGetAIUsageStatsRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	month *string
}

// Month to retrieve statistics for (YYYY-MM format)
func (r AIServicesAPIGetAIUsageStatsRequest) Month(month string) AIServicesAPIGetAIUsageStatsRequest {
	r.month = &month
	return r
}

func (r AIServicesAPIGetAIUsageStatsRequest) Execute() (*GetAIUsageStats200Response, *http.Response, error) {
	return r.ApiService.GetAIUsageStatsExecute(r)
}

/*
GetAIUsageStats Get AI usage statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIGetAIUsageStatsRequest
*/
func (a *AIServicesAPIService) GetAIUsageStats(ctx context.Context, organisation string) AIServicesAPIGetAIUsageStatsRequest {
	return AIServicesAPIGetAIUsageStatsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return GetAIUsageStats200Response
func (a *AIServicesAPIService) GetAIUsageStatsExecute(r AIServicesAPIGetAIUsageStatsRequest) (*GetAIUsageStats200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAIUsageStats200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.GetAIUsageStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/usage"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.month != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "month", r.month, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIGetToolExecutionStatusRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	executionId string
}

func (r AIServicesAPIGetToolExecutionStatusRequest) Execute() (*GetToolExecutionStatus200Response, *http.Response, error) {
	return r.ApiService.GetToolExecutionStatusExecute(r)
}

/*
GetToolExecutionStatus Get async tool execution status and result

Retrieves the status and result of an async tool execution. Used for polling long-running tools like image generation.
     *
     * **Async Tool Execution Pattern:**
     * This endpoint enables a polling pattern for long-running tools that would otherwise hit API Gateway's 30-second timeout.
     *
     * **Flow:**
     * 1. AI requests tool use (e.g., `generate_image`)
     * 2. Chat API returns `toolUse` with execution tracking info
     * 3. Client starts polling this endpoint with the `executionId`
     * 4. When `status === 'complete'`, retrieve `result` and send back to AI
     * 5. AI incorporates result into final response
     *
     * **Status Values:**
     * - `pending`: Tool execution queued, not yet started
     * - `running`: Tool is currently executing
     * - `complete`: Tool execution finished successfully, `result` available
     * - `failed`: Tool execution failed, `error` available
     *
     * **Polling Recommendations:**
     * - Poll every 2-3 seconds for image generation
     * - Exponential backoff for other tools (start 1s, max 5s)
     * - Stop polling after 5 minutes (consider failed)
     * - Auto-cleanup after 24 hours (TTL)
     *
     * **Use Cases:**
     * - Image generation (10-15s typical runtime)
     * - Video processing
     * - Large file uploads/downloads
     * - Complex database queries
     * - External API calls with high latency

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param executionId Tool execution identifier
 @return AIServicesAPIGetToolExecutionStatusRequest
*/
func (a *AIServicesAPIService) GetToolExecutionStatus(ctx context.Context, organisation string, executionId string) AIServicesAPIGetToolExecutionStatusRequest {
	return AIServicesAPIGetToolExecutionStatusRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		executionId: executionId,
	}
}

// Execute executes the request
//  @return GetToolExecutionStatus200Response
func (a *AIServicesAPIService) GetToolExecutionStatusExecute(r AIServicesAPIGetToolExecutionStatusRequest) (*GetToolExecutionStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetToolExecutionStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.GetToolExecutionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tools/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetToolExecutionStatus404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIImageGenerationRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	imageGenerationRequest *ImageGenerationRequest
}

// Image generation request
func (r AIServicesAPIImageGenerationRequest) ImageGenerationRequest(imageGenerationRequest ImageGenerationRequest) AIServicesAPIImageGenerationRequest {
	r.imageGenerationRequest = &imageGenerationRequest
	return r
}

func (r AIServicesAPIImageGenerationRequest) Execute() (*ImageGeneration200Response, *http.Response, error) {
	return r.ApiService.ImageGenerationExecute(r)
}

/*
ImageGeneration Generate images with Amazon Nova Canvas

Generates images using Amazon Nova Canvas image generation model.
     *
     * **Region Restriction:** Nova Canvas is ONLY available in:
     * - `us-east-1` (US East, N. Virginia)
     * - `ap-northeast-1` (Asia Pacific, Tokyo)
     * - `eu-west-1` (Europe, Ireland)
     * âŒ NOT available in `ap-southeast-2` (Sydney)
     *
     * **Supported Task Types:**
     * - **TEXT_IMAGE**: Basic text-to-image generation
     * - **TEXT_IMAGE with Conditioning**: Layout-guided generation using edge detection or segmentation
     * - **COLOR_GUIDED_GENERATION**: Generate images with specific color palettes
     * - **IMAGE_VARIATION**: Create variations of existing images
     * - **INPAINTING**: Fill masked areas in images
     * - **OUTPAINTING**: Extend images beyond their borders
     * - **BACKGROUND_REMOVAL**: Remove backgrounds from images
     * - **VIRTUAL_TRY_ON**: Try on garments/objects on people
     *
     * **Quality Options:**
     * - **standard**: Faster generation, lower cost
     * - **premium**: Higher quality, slower generation
     *
     * **Timeout:** Image generation can take up to 5 minutes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIImageGenerationRequest
*/
func (a *AIServicesAPIService) ImageGeneration(ctx context.Context, organisation string) AIServicesAPIImageGenerationRequest {
	return AIServicesAPIImageGenerationRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ImageGeneration200Response
func (a *AIServicesAPIService) ImageGenerationExecute(r AIServicesAPIImageGenerationRequest) (*ImageGeneration200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageGeneration200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.ImageGeneration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/image-generation"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.imageGenerationRequest == nil {
		return localVarReturnValue, nil, reportError("imageGenerationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.imageGenerationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIListAIModelsRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	feature *string
}

// Filter models by supported feature
func (r AIServicesAPIListAIModelsRequest) Feature(feature string) AIServicesAPIListAIModelsRequest {
	r.feature = &feature
	return r
}

func (r AIServicesAPIListAIModelsRequest) Execute() (*ListAIModels200Response, *http.Response, error) {
	return r.ApiService.ListAIModelsExecute(r)
}

/*
ListAIModels List available AI models for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIListAIModelsRequest
*/
func (a *AIServicesAPIService) ListAIModels(ctx context.Context, organisation string) AIServicesAPIListAIModelsRequest {
	return AIServicesAPIListAIModelsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListAIModels200Response
func (a *AIServicesAPIService) ListAIModelsExecute(r AIServicesAPIListAIModelsRequest) (*ListAIModels200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAIModels200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.ListAIModels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/models"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.feature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "feature", r.feature, "form", "")
	} else {
		var defaultValue string = "all"
		r.feature = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIListAISessionsRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	userId *string
	sessionGroup *string
	limit *int32
	offset *int32
	model *string
}

// Filter sessions by user ID
func (r AIServicesAPIListAISessionsRequest) UserId(userId string) AIServicesAPIListAISessionsRequest {
	r.userId = &userId
	return r
}

// Filter by session group. Returns only sessions matching the specified group.
func (r AIServicesAPIListAISessionsRequest) SessionGroup(sessionGroup string) AIServicesAPIListAISessionsRequest {
	r.sessionGroup = &sessionGroup
	return r
}

// Maximum number of sessions to return (default 50, max 100)
func (r AIServicesAPIListAISessionsRequest) Limit(limit int32) AIServicesAPIListAISessionsRequest {
	r.limit = &limit
	return r
}

// Offset for pagination
func (r AIServicesAPIListAISessionsRequest) Offset(offset int32) AIServicesAPIListAISessionsRequest {
	r.offset = &offset
	return r
}

// Filter by model ID
func (r AIServicesAPIListAISessionsRequest) Model(model string) AIServicesAPIListAISessionsRequest {
	r.model = &model
	return r
}

func (r AIServicesAPIListAISessionsRequest) Execute() ([]ListAISessions200ResponseInner, *http.Response, error) {
	return r.ApiService.ListAISessionsExecute(r)
}

/*
ListAISessions List chat sessions with multi-tenant filtering

Lists active sessions for an organization with flexible filtering options.
     *
     * **Query Combinations:**
     * 1. By Organization (default): Returns all sessions in the organization
     * 2. By Organization + Group: `?sessionGroup=drupal-prod` - Sessions in a specific group
     * 3. By User: `?userId=user-123` - All sessions for a user
     * 4. By User + Group: `?userId=user-123&sessionGroup=drupal-prod` - User's sessions in a specific group
     *
     * **Use Cases:**
     * - List user's conversations in a specific app/environment
     * - Admin view of all sessions in a customer/tenant group
     * - User profile showing all AI conversations across apps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIListAISessionsRequest
*/
func (a *AIServicesAPIService) ListAISessions(ctx context.Context, organisation string) AIServicesAPIListAISessionsRequest {
	return AIServicesAPIListAISessionsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return []ListAISessions200ResponseInner
func (a *AIServicesAPIService) ListAISessionsExecute(r AIServicesAPIListAISessionsRequest) ([]ListAISessions200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListAISessions200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.ListAISessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.sessionGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionGroup", r.sessionGroup, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIListAIToolNamesRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
}

func (r AIServicesAPIListAIToolNamesRequest) Execute() (*ListAIToolNames200Response, *http.Response, error) {
	return r.ApiService.ListAIToolNamesExecute(r)
}

/*
ListAIToolNames List tool names only (lightweight response)

Retrieves just the names of available built-in tools. Useful for quick validation or UI dropdown population without the full tool specifications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIListAIToolNamesRequest
*/
func (a *AIServicesAPIService) ListAIToolNames(ctx context.Context, organisation string) AIServicesAPIListAIToolNamesRequest {
	return AIServicesAPIListAIToolNamesRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListAIToolNames200Response
func (a *AIServicesAPIService) ListAIToolNamesExecute(r AIServicesAPIListAIToolNamesRequest) (*ListAIToolNames200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAIToolNames200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.ListAIToolNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tools/names"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIListAIToolsRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
}

func (r AIServicesAPIListAIToolsRequest) Execute() (*ListAITools200Response, *http.Response, error) {
	return r.ApiService.ListAIToolsExecute(r)
}

/*
ListAITools List available built-in tools for function calling

Retrieves all available built-in tools that can be used with function calling. These tools can be included in `toolConfig` when making AI inference requests.
     *
     * **Available Built-in Tools:**
     * - `get_weather`: Get current weather for a location using Open-Meteo API
     * - `calculate`: Perform basic mathematical calculations (add, subtract, multiply, divide)
     * - `search_web`: Search the web for information (mock implementation)
     * - `generate_image`: Generate images with Amazon Nova Canvas (async execution, 10-15s typical runtime)
     *
     * **Use Cases:**
     * - Discover available tools dynamically without hardcoding
     * - Get complete tool specifications including input schemas
     * - Build UI for tool selection
     * - Validate tool names before sending requests
     *
     * **Dynamic Tool Discovery:**
     * This endpoint enables clients to:
     * 1. Fetch all available tools on page load
     * 2. Display tool capabilities to users
     * 3. Filter tools based on user permissions
     * 4. Use `allowedTools` whitelist for security
     *
     * **Alternative Endpoint:**
     * - `GET /ai/tools/names` - Returns only tool names (faster, lighter response)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIListAIToolsRequest
*/
func (a *AIServicesAPIService) ListAITools(ctx context.Context, organisation string) AIServicesAPIListAIToolsRequest {
	return AIServicesAPIListAIToolsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListAITools200Response
func (a *AIServicesAPIService) ListAIToolsExecute(r AIServicesAPIListAIToolsRequest) (*ListAITools200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAITools200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.ListAITools")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tools"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIListToolExecutionsRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	status *string
	limit *int32
}

// Filter by execution status
func (r AIServicesAPIListToolExecutionsRequest) Status(status string) AIServicesAPIListToolExecutionsRequest {
	r.status = &status
	return r
}

// Maximum number of executions to return
func (r AIServicesAPIListToolExecutionsRequest) Limit(limit int32) AIServicesAPIListToolExecutionsRequest {
	r.limit = &limit
	return r
}

func (r AIServicesAPIListToolExecutionsRequest) Execute() (*ListToolExecutions200Response, *http.Response, error) {
	return r.ApiService.ListToolExecutionsExecute(r)
}

/*
ListToolExecutions List tool executions for monitoring and debugging

Lists recent async tool executions for an organization. Useful for debugging, monitoring, and building admin UIs.
     *
     * **Query Patterns:**
     * - All recent executions: `GET /ai/tools/executions`
     * - Filter by status: `GET /ai/tools/executions?status=running`
     * - Limit results: `GET /ai/tools/executions?limit=20`
     *
     * **Results:**
     * - Ordered by creation time (newest first)
     * - Limited to 50 by default (configurable via `limit` parameter)
     * - Only shows executions not yet expired (24h TTL)
     *
     * **Use Cases:**
     * - Monitor all active tool executions
     * - Debug failed executions
     * - Build admin dashboards
     * - Track tool usage patterns
     * - Audit async operations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIListToolExecutionsRequest
*/
func (a *AIServicesAPIService) ListToolExecutions(ctx context.Context, organisation string) AIServicesAPIListToolExecutionsRequest {
	return AIServicesAPIListToolExecutionsRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ListToolExecutions200Response
func (a *AIServicesAPIService) ListToolExecutionsExecute(r AIServicesAPIListToolExecutionsRequest) (*ListToolExecutions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListToolExecutions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.ListToolExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/tools/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AIServicesAPIUpdateAIConfigRequest struct {
	ctx context.Context
	ApiService AIServicesAPI
	organisation string
	updateAIConfigRequest *UpdateAIConfigRequest
}

func (r AIServicesAPIUpdateAIConfigRequest) UpdateAIConfigRequest(updateAIConfigRequest UpdateAIConfigRequest) AIServicesAPIUpdateAIConfigRequest {
	r.updateAIConfigRequest = &updateAIConfigRequest
	return r
}

func (r AIServicesAPIUpdateAIConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAIConfigExecute(r)
}

/*
UpdateAIConfig Update AI configuration for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return AIServicesAPIUpdateAIConfigRequest
*/
func (a *AIServicesAPIService) UpdateAIConfig(ctx context.Context, organisation string) AIServicesAPIUpdateAIConfigRequest {
	return AIServicesAPIUpdateAIConfigRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
func (a *AIServicesAPIService) UpdateAIConfigExecute(r AIServicesAPIUpdateAIConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AIServicesAPIService.UpdateAIConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/ai/config"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAIConfigRequest == nil {
		return nil, reportError("updateAIConfigRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAIConfigRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

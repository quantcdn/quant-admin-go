/*
QuantCDN API

Unified API for QuantCDN Admin and QuantCloud Platform services

API version: 4.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package quantadmingo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ComposeAPI interface {

	/*
	GetEnvironmentCompose Get the compose file for an environment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@param application The application ID
	@param environment The environment ID
	@return ComposeAPIGetEnvironmentComposeRequest
	*/
	GetEnvironmentCompose(ctx context.Context, organisation string, application string, environment string) ComposeAPIGetEnvironmentComposeRequest

	// GetEnvironmentComposeExecute executes the request
	//  @return Compose
	GetEnvironmentComposeExecute(r ComposeAPIGetEnvironmentComposeRequest) (*Compose, *http.Response, error)

	/*
	ValidateCompose Validate a compose file

	Accepts a docker-compose.yml file content, translates it into the internal compose definition format, and validates it. Quant Cloud provides comprehensive support for standard Docker Compose features including commands, entrypoints, health checks, dependencies, volume mounts, resource limits, and more. For detailed documentation on supported features and examples, see: https://docs.quantcdn.io/introduction-to-quant-cloud/importing-docker-compose/. Supports image tag suffixing via the imageSuffix query parameter or by sending a JSON wrapper with yamlContent and imageSuffix fields. When provided, internal image tags are transformed to {containerName}-{suffix} format (e.g., 'nginx-feature-xyz').

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organisation The organisation ID
	@return ComposeAPIValidateComposeRequest
	*/
	ValidateCompose(ctx context.Context, organisation string) ComposeAPIValidateComposeRequest

	// ValidateComposeExecute executes the request
	//  @return ValidateCompose200Response
	ValidateComposeExecute(r ComposeAPIValidateComposeRequest) (*ValidateCompose200Response, *http.Response, error)
}

// ComposeAPIService ComposeAPI service
type ComposeAPIService service

type ComposeAPIGetEnvironmentComposeRequest struct {
	ctx context.Context
	ApiService ComposeAPI
	organisation string
	application string
	environment string
}

func (r ComposeAPIGetEnvironmentComposeRequest) Execute() (*Compose, *http.Response, error) {
	return r.ApiService.GetEnvironmentComposeExecute(r)
}

/*
GetEnvironmentCompose Get the compose file for an environment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @param application The application ID
 @param environment The environment ID
 @return ComposeAPIGetEnvironmentComposeRequest
*/
func (a *ComposeAPIService) GetEnvironmentCompose(ctx context.Context, organisation string, application string, environment string) ComposeAPIGetEnvironmentComposeRequest {
	return ComposeAPIGetEnvironmentComposeRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
		application: application,
		environment: environment,
	}
}

// Execute executes the request
//  @return Compose
func (a *ComposeAPIService) GetEnvironmentComposeExecute(r ComposeAPIGetEnvironmentComposeRequest) (*Compose, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Compose
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComposeAPIService.GetEnvironmentCompose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/compose"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", url.PathEscape(parameterValueToString(r.application, "application")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment"+"}", url.PathEscape(parameterValueToString(r.environment, "environment")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComposeAPIValidateComposeRequest struct {
	ctx context.Context
	ApiService ComposeAPI
	organisation string
	validateComposeRequest *ValidateComposeRequest
	imageSuffix *string
}

// The docker-compose.yml file content. Can be sent as raw YAML string or as a JSON wrapper containing both yamlContent (string) and imageSuffix (string) fields. Query parameter imageSuffix takes precedence if both are provided.
func (r ComposeAPIValidateComposeRequest) ValidateComposeRequest(validateComposeRequest ValidateComposeRequest) ComposeAPIValidateComposeRequest {
	r.validateComposeRequest = &validateComposeRequest
	return r
}

// Optional. Image tag suffix to apply during translation. Transforms internal image tags to consistent &#39;{containerName}-{suffix}&#39; format (e.g., &#39;nginx-pr-456&#39;). External images are left unchanged. Useful for feature branch deployments.
func (r ComposeAPIValidateComposeRequest) ImageSuffix(imageSuffix string) ComposeAPIValidateComposeRequest {
	r.imageSuffix = &imageSuffix
	return r
}

func (r ComposeAPIValidateComposeRequest) Execute() (*ValidateCompose200Response, *http.Response, error) {
	return r.ApiService.ValidateComposeExecute(r)
}

/*
ValidateCompose Validate a compose file

Accepts a docker-compose.yml file content, translates it into the internal compose definition format, and validates it. Quant Cloud provides comprehensive support for standard Docker Compose features including commands, entrypoints, health checks, dependencies, volume mounts, resource limits, and more. For detailed documentation on supported features and examples, see: https://docs.quantcdn.io/introduction-to-quant-cloud/importing-docker-compose/. Supports image tag suffixing via the imageSuffix query parameter or by sending a JSON wrapper with yamlContent and imageSuffix fields. When provided, internal image tags are transformed to {containerName}-{suffix} format (e.g., 'nginx-feature-xyz').

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisation The organisation ID
 @return ComposeAPIValidateComposeRequest
*/
func (a *ComposeAPIService) ValidateCompose(ctx context.Context, organisation string) ComposeAPIValidateComposeRequest {
	return ComposeAPIValidateComposeRequest{
		ApiService: a,
		ctx: ctx,
		organisation: organisation,
	}
}

// Execute executes the request
//  @return ValidateCompose200Response
func (a *ComposeAPIService) ValidateComposeExecute(r ComposeAPIValidateComposeRequest) (*ValidateCompose200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateCompose200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComposeAPIService.ValidateCompose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/organizations/{organisation}/compose/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"organisation"+"}", url.PathEscape(parameterValueToString(r.organisation, "organisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validateComposeRequest == nil {
		return localVarReturnValue, nil, reportError("validateComposeRequest is required and must be specified")
	}

	if r.imageSuffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageSuffix", r.imageSuffix, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validateComposeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidateCompose422Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
